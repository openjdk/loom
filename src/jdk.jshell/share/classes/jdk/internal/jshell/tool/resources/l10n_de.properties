#
# Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
#
# This code is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 2 only, as
# published by the Free Software Foundation.  Oracle designates this
# particular file as subject to the "Classpath" exception as provided
# by Oracle in the LICENSE file that accompanied this code.
#
# This code is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# version 2 for more details (a copy is included in the LICENSE file that
# accompanied this code).
#
# You should have received a copy of the GNU General Public License version
# 2 along with this work; if not, write to the Free Software Foundation,
# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
#
# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
# or visit www.oracle.com if you need additional information or have any
# questions.
#

jshell.msg.welcome =Willkommen bei JShell - Version {0}\nGeben Sie f\u00FCr eine Einf\u00FChrung Folgendes ein: /help intro
jshell.err.opt.arg = Argument f\u00FCr {0} fehlt.
jshell.err.opt.invalid = Ung\u00FCltige Optionen: {0}.
jshell.err.opt.one = Es darf nur eine {0}-Option verwendet werden.
jshell.err.opt.startup.conflict = Nicht miteinander vereinbare Optionen: Es wurde sowohl --startup als auch --no-startup verwendet.
jshell.err.opt.feedback.one = Es darf nur eine Feedbackoption (--feedback, -q, -s oder -v) verwendet werden.
jshell.err.opt.unknown = Unbekannte Option: {0}

jshell.msg.terminated = Status-Engine beendet.
jshell.msg.terminated.restore = Stellen Sie Definitionen wieder her mit: /reload -restore

jshell.msg.use.one.of = Verwenden Sie eine der folgenden Optionen: {0}
jshell.msg.see.classes.etc = Siehe /types, /methods, /vars oder /list
jshell.err.arg = Ung\u00FCltiges "{0}"-Argument: {1}
jshell.msg.see = Hilfe finden Sie unter {0}.

jshell.err.file.not.accessible = Auf Datei "{1}" f\u00FCr "{0}" kann nicht zugegriffen werden: {2}
jshell.err.file.not.found = Datei "{1}" f\u00FCr "{0}" nicht gefunden.
jshell.err.file.exception = Datei "{1}" f\u00FCr "{0}" hat eine Ausnahme ausgel\u00F6st: {2}
jshell.err.file.filename = F\u00FCr "{0}" muss ein Dateinamenargument angegeben werden.

jshell.err.startup.unexpected.exception = Unerwartete Ausnahme beim Lesen von Startinformationen: {0}
jshell.err.unexpected.exception = Unerwartete Ausnahme: {0}

jshell.err.invalid.command = Ung\u00FCltiger Befehl: {0}
jshell.err.command.ambiguous = Befehl "{0}" ist mehrdeutig: {1}
jshell.msg.set.restore = Es werden neue Optionen festgelegt, und der Status wird wiederhergestellt.
jshell.msg.set.editor.set = Editor gesetzt auf: {0}
jshell.msg.set.editor.retain = Editoreinstellung beibehalten: {0}
jshell.msg.set.indent.set = Einzugsebene gesetzt auf: {0}
jshell.err.invalid.indent = Ung\u00FCltige Einzugsebene: {0}
jshell.err.no.builtin.editor = Integrierter Editor nicht verf\u00FCgbar.
jshell.err.cant.launch.editor = Integrierter Editor kann nicht gestartet werden - unerwartete Ausnahme: {0}
jshell.msg.try.set.editor = Informationen zum Verwenden des externen Editors finden Sie unter "/help /set editor".
jshell.msg.press.return.to.leave.edit.mode = Dr\u00FCcken Sie die Eingabetaste, um den Bearbeitungsmodus zu verlassen.
jshell.err.wait.applies.to.external.editor = -wait gilt f\u00FCr externe Editoren
jshell.label.editpad = JShell-Bearbeitungs-Pad

jshell.err.setting.to.retain.must.be.specified = Die beizubehaltende Einstellung muss angegeben werden - {0}
jshell.msg.set.show.mode.settings = \nVerwenden Sie zum Anzeigen der Moduseinstellungen "/set prompt", "/set truncation", ...,\noder verwenden Sie "/set mode" gefolgt von dem Feedbackmodusnamen.
jshell.err.continuation.prompt.required = Fortsetzungs-Prompt erforderlich - {0}

jshell.msg.try.command.without.args = Verwenden Sie "{0}" ohne Argumente.
jshell.msg.no.active = Keine aktiven Definitionen vorhanden.

jshell.msg.resetting = Wird zur\u00FCckgesetzt...
jshell.msg.resetting.state = Status wird zur\u00FCckgesetzt.

jshell.err.reload.no.previous = Keine vorherige Historie zum Wiederherstellen vorhanden
jshell.err.reload.restarting.previous.state = Es wird ein Neustart ausgef\u00FChrt und der vorherige Status wiederhergestellt.
jshell.err.reload.restarting.state = Neustart wird ausgef\u00FChrt und Status wiederhergestellt.

jshell.err.restart.failed = Neustart nicht erfolgreich: {0}\n\nVorherige Einstellungen werden wiederhergestellt, und ein Neustart wird ausgef\u00FChrt...

jshell.msg.vars.not.active = (nicht aktiv)

jshell.err.out.of.range = Au\u00DFerhalb des zul\u00E4ssigen Bereichs

jshell.msg.error = Fehler:
jshell.msg.warning = Warnung:

jshell.err.sub.arg = F\u00FCr den Befehl "{0}" ist ein Unterbefehl erforderlich. Siehe: "/help {0}"
jshell.err.sub.ambiguous = Mehrdeutiges Unterbefehlsargument f\u00FCr "{0}": {1}

jshell.err.classpath.arg = F\u00FCr den /classpath-Befehl ist ein Pfadargument erforderlich.
jshell.msg.classpath = Pfad "{0}" zu Classpath hinzugef\u00FCgt

jshell.err.help.arg = Es beginnen keine Befehle oder Themen mit dem angegebenen Argument: {0}
jshell.msg.help.begin =Geben Sie einen Java-Sprachausdruck, eine Anweisung oder eine Deklaration ein.\nSie k\u00F6nnen auch einen der folgenden Befehle eingeben:\n
jshell.msg.help.subject =\nUm weitere Informationen zu erhalten, geben Sie "/help" gefolgt von dem Namen\neines Befehls oder Themas ein.\nBeispiel: "/help /list" oder "/help intro".\n\nThemen:\n\n

jshell.err.no.snippet.with.id = Kein Snippet mit ID: {0}
jshell.err.end.snippet.range.less.than.start = Snippet-Bereichsende niedriger als Bereichsanfang: {0} - {1}
jshell.err.range.requires.id = F\u00FCr Snippet-Bereiche sind Snippet-IDs erforderlich: {0}

jshell.err.exit.not.expression = Das Argument f\u00FCr /exit muss ein g\u00FCltiger ganzzahliger Ausdruck sein. Es ist jedoch kein Ausdruck: {0}
jshell.err.exit.bad.type = Das Argument f\u00FCr /exit muss ein g\u00FCltiger ganzzahliger Ausdruck sein. Der Typ ist {1} : {0}
jshell.err.exit.bad.value = Das Argument f\u00FCr /exit besitzt den ung\u00FCltigen Wert {1} : {0}

jshell.err.drop.arg =Geben Sie im /drop-Argument einen zu l\u00F6schenden Import oder eine zu l\u00F6schende Variable, Methode oder Klasse an.\nGeben Sie die Elemente nach ID oder Name an. Verwenden Sie /list, um IDs anzuzeigen. Verwenden Sie /reset, um den gesamten Status zur\u00FCckzusetzen.
jshell.err.failed = Nicht erfolgreich.
jshell.msg.native.method = Native Methode
jshell.msg.unknown.source = Unbekannte Quelle 
jshell.msg.goodbye = Auf Wiedersehen
jshell.msg.goodbye.value = Auf Wiedersehen ({0})

jshell.msg.help.for.help = Geben Sie /help f\u00FCr einen Hilfetext ein.

jshell.err.mode.name = Feedbackmodusname erwartet: {0}
jshell.err.missing.mode = Feedbackmodus fehlt - {0}
jshell.err.field.name = Feldname erwartet: {0} - {1}
jshell.err.mode.unknown = Kein Feedbackmodus benannt: {0} - {1}

jshell.err.feedback.does.not.match.mode = Entspricht keinem aktuellen Feedbackmodus: {0} - {1}
jshell.err.feedback.ambiguous.mode = Entspricht mehr als einem aktuellen Feedbackmodus: {0} - {1}
jshell.err.feedback.must.be.quoted = Format "{0}" muss in Anf\u00FChrungszeichen gesetzt werden - {1}
jshell.err.feedback.not.a.valid.selector = Kein g\u00FCltiger Selektor "{0}" in "{1}" - {2}
jshell.err.feedback.multiple.sections = Art des Selektors in mehreren Abschnitten der Selektorliste "{0}" in "{1}" - {2}
jshell.err.feedback.different.selector.kinds = Unterschiedliche Arten von Selektoren in denselben Abschnitten der Selektorliste "{0}" in "{1}" - {2}

jshell.msg.feedback.new.mode = Neuen Feedbackmodus erstellt: {0}
jshell.msg.feedback.mode = Feedbackmodus: {0}
jshell.msg.feedback.mode.following = Verf\u00FCgbare Feedbackmodi:
jshell.msg.feedback.retained.mode.following = Beibehaltene Feedbackmodi:
jshell.err.mode.creation = Zum Erstellen eines neuen Modus muss entweder die Option -command oder die Option -quiet verwendet werden - {0}
jshell.err.mode.exists = Zu erstellender Modus ist bereits vorhanden: {0} - {1}

jshell.err.truncation.expected.length = Erwartete Abschneidel\u00E4nge - {0}
jshell.err.truncation.length.not.integer = Abschneidel\u00E4nge muss eine Ganzzahl sein: {0} - {1}

jshell.err.not.valid.with.predefined.mode = Nicht g\u00FCltig mit einem vordefinierten Modus: {0} - {1}
jshell.err.retained.feedback.mode.must.be.retained.or.predefined = F\u00FCr "/set feedback -retain <Modus>" muss <Modus> vordefiniert werden oder mit "/set mode -retain" beibehalten worden sein - {0}

jshell.err.unknown.option = Unbekannte Option: {0} - {1}
jshell.err.default.option.or.program = Geben Sie Option -default, Option -delete oder das Programm an - {0}
jshell.err.option.or.filename = Geben Sie maximal eine der Optionen -default, -none oder einen Startdateinamen an - {0}
jshell.err.unexpected.at.end = Unerwartete Argumente am Ende des Befehls: {0} - {1}
jshell.err.conflicting.options = Nicht miteinander vereinbare Optionen - {0}
jshell.err.cannot.delete.current.mode = Der aktuelle Feedbackmodus "{0}" kann nicht gel\u00F6scht werden. Verwenden Sie zun\u00E4chst "/set feedback" - {1}
jshell.err.cannot.delete.retained.mode = Der beibehaltene Feedbackmodus "{0}" kann nicht gel\u00F6scht werden. Verwenden Sie zun\u00E4chst "/set feedback -retain" - {1}
jshell.err.may.not.specify.options.and.snippets = Optionen und Snippets d\u00FCrfen nicht gemeinsam verwendet werden: {0}
jshell.err.no.such.snippets = Snippet nicht vorhanden: {0}
jshell.err.the.snippet.cannot.be.used.with.this.command = Dieser Befehl akzeptiert das Snippet "{0}" nicht: {1}
jshell.err.retained.mode.failure = Fehler in beibehaltenen Modi (Modi gel\u00F6scht) - {0} {1}

jshell.err.corrupted.stored.startup = Gespeicherter Start besch\u00E4digt. Standardwert wird verwendet - {0}

jshell.err.exception.thrown = Ausnahme {0}
jshell.err.exception.thrown.message = Ausnahme {0}: {1}
jshell.err.exception.cause = Verursacht von: {0}
jshell.err.exception.cause.message = Verursacht von: {0}: {1}

jshell.console.see.synopsis = <Erneut Tabulatortaste dr\u00FCcken, um Zusammenfassung anzuzeigen>
jshell.console.see.full.documentation = <Erneut Tabulatortaste dr\u00FCcken, um vollst\u00E4ndige Dokumentation anzuzeigen>
jshell.console.see.documentation = <Erneut Tabulatortaste dr\u00FCcken, um Dokumentation anzuzeigen>
jshell.console.see.next.page = <Erneut Tabulatortaste dr\u00FCcken, um n\u00E4chste Seite anzuzeigen>
jshell.console.see.next.javadoc = <Tabulatortaste dr\u00FCcken, um n\u00E4chste Dokumentation anzuzeigen>
jshell.console.see.next.command.doc = <Tabulatortaste dr\u00FCcken, um n\u00E4chsten Befehl anzuzeigen>
jshell.console.no.such.command = Befehl nicht vorhanden
jshell.console.completion.current.signatures = Signaturen:
jshell.console.completion.all.completions.number = <Erneut Tabulatortaste dr\u00FCcken, um alle m\u00F6glichen Abschl\u00FCsse anzuzeigen. Insgesamt m\u00F6gliche Abschl\u00FCsse: {0}>
jshell.console.completion.all.completions = <Erneut Tabulatortaste dr\u00FCcken, um alle m\u00F6glichen Abschl\u00FCsse anzuzeigen>
jshell.console.no.javadoc = <Keine Dokumentation gefunden>
jshell.console.do.nothing = Nichts machen
jshell.console.choice = Auswahl: 
jshell.console.create.variable = Variable erstellen
jshell.console.create.method = Methode erstellen
jshell.console.resolvable = \nDie ID kann in diesem Kontext aufgel\u00F6st werden.
jshell.console.no.candidate = \nKeine vollqualifizierten Kandidatennamen f\u00FCr Import gefunden.
jshell.console.incomplete = \nErgebnisse sind m\u00F6glicherweise unvollst\u00E4ndig. Wiederholen Sie den Vorgang sp\u00E4ter, um vollst\u00E4ndige Ergebnisse zu erhalten.
jshell.console.erroneous = \nUnvollst\u00E4ndig oder fehlerhaft. Ein einzelner g\u00FCltiger Ausdruck oder eine einzelne g\u00FCltige Anweisung muss Umschalt+Tab gefolgt von M vorangehen.
jshell.console.exprstmt = \nEin einzelner g\u00FCltiger Ausdruck oder eine einzelne g\u00FCltige Anweisung muss Umschalt+Tab gefolgt von M vorangehen.
jshell.console.empty = \nLeerer Eintrag. Ein einzelner g\u00FCltiger Ausdruck oder eine einzelne g\u00FCltige Anweisung muss Umschalt+Tab gefolgt von M vorangehen.

jshell.fix.wrong.shortcut =Unerwartetes Zeichen nach Umschalt+Tab.\nVerwenden Sie "I" f\u00FCr automatischen Import, "V" zur Variablenerstellung oder "M" zur Methodenerstellung.\nWeitere Informationen finden Sie unter:\n/help shortcuts

help.usage = Verwendung:   jshell <Option>... <Ladedatei>...\nM\u00F6gliche Optionen:\n    --class-path <Pfad>   Gibt an, wo die Benutzerklassendateien gespeichert sind\n    --module-path <Pfad>  Gibt an, wo die Anwendungsmodule gespeichert sind\n    --add-modules <Modul>(,<Modul>)*\n                          Gibt aufzul\u00F6sende Module oder alle Module im\n                            Modulpfad an, wenn <Modul> ALL-MODULE-PATHs ist\n    --enable-native-access\n                          Erm\u00F6glicht Ausf\u00FChrung eingeschr\u00E4nkter nativer Methoden durch Code\n    --enable-preview      Code kann Vorschaufeatures in diesem Release nutzen\n    --startup <Datei>      Ersetzung der Startdefinitionen mit einer Ausf\u00FChrung\n    --no-startup          Startdefinitionen werden nicht ausgef\u00FChrt\n    --feedback <Modus>     Gibt den anf\u00E4nglichen Feedbackmodus an. Der Modus kann\n                            vordefiniert (Silent, Concise, Normal oder Verbose) oder\n                            vorab benutzerdefiniert sein\n    -q                    Stilles Feedback. Identisch mit: --feedback concise\n    -s                    \u00C4u\u00DFerst stilles Feedback. Identisch mit: --feedback silent\n    -v                    Verbose-Feedback. Identisch mit: --feedback verbose\n    -J<Kennzeichen>              \u00DCbergibt <Kennzeichen> direkt an das Laufzeitsystem.\n                            Verwenden Sie ein -J pro Laufzeitkennzeichen oder Kennzeichenargument\n    -R<Kennzeichen>              \u00DCbergibt <Kennzeichen> an das Remotelaufzeitsystem.\n                            Verwenden Sie ein -R pro Remotekennzeichen oder Kennzeichenargument\n    -C<Kennzeichen>              \u00DCbergibt <Kennzeichen> an den Compiler.\n                            Verwenden Sie ein -C pro Compiler-Kennzeichen oder Kennzeichenargument\n    --version             Gibt Versionsinformationen aus und beendet den Vorgang\n    --show-version        Gibt Versionsinformationen aus und setzt den Vorgang fort\n    --help, -?, -h        Gibt diese Zusammenfassung der Standardoptionen aus und beendet den Vorgang\n    --help-extra, -X      Gibt Hilfetext zu Nicht-Standardoptionen aus und beendet den Vorgang\n\nEin Dateiargument kann ein Dateiname oder einer der vordefinierten Dateinamen sein: DEFAULT,\nPRINTING oder JAVASE.\nEine Ladedatei kann auch "-" zur Angabe einer Standardeingabe ohne interaktiven I/O sein.\n\nWeitere Informationen zu den Auswertungskontextoptionen (--class-path,\n--module-path und --add-modules) finden Sie unter:\n\t/help context\n\nEin Pfad listet die zu durchsuchenden Verzeichnisse und Archive auf. Verwenden Sie unter Windows ein\nSemikolon (;), um Elemente im Pfad zu trennen. Verwenden Sie auf anderen Plattformen einen\nDoppelpunkt (:), um Elemente zu trennen.\n
help.usage.x = \    --add-exports <Modul>/<Package>   Gibt ein Package an, das als\n                                         Export aus seinem definierenden Modul gelten soll \n    --execution <Spezifikation>                 Gibt eine alternative Ausf\u00FChrungs-Engine an.\n                                         Dabei gilt: <Spezifikation> ist eine ExecutionControl-Spezifikation.\n                                         In der Dokumentation zu dem Package\n                                         jdk.jshell.spi finden Sie Informationen zur Syntax der Spezifikation\n    \nDies sind keine Standardoptionen und k\u00F6nnen jederzeit ohne vorherige Ank\u00FCndigung ge\u00E4ndert werden.\n

help.list.summary = Listet die eingegebene Quelle auf
help.list.args = [<Name oder ID>|-all|-start]
help.list =Zeigt die Snippets mit vorangestellten Snippet-IDs an.\n\n/list\n\tListet die derzeit aktiven Code-Snippets auf, die Sie eingegeben oder mit /open eingelesen haben\n\n/list -start\n\tListet die ausgewerteten Start-Snippets auf\n\n/list -all\n\tListet alle Snippets auf, einschlie\u00DFlich aller nicht erfolgreichen, \u00FCberschriebenen, gel\u00F6schten und Start-Snippets\n\n/list <Name>\n\tListet Snippets mit dem angegebenen Namen auf (aktive Snippets werden bevorzugt aufgef\u00FChrt)\n\n/list <ID>\n\tF\u00FChrt das Snippet mit der angegebenen Snippet-ID auf.\n\tEs k\u00F6nnen mehrere IDs oder ID-Bereiche verwendet werden, siehe "/help id"

help.edit.summary = Bearbeitet einen Quelleintrag
help.edit.args = <Name oder ID>
help.edit =Bearbeitet ein oder mehrere Code-Snippets in einem externen Editor.\nDer zu verwendende Editor wird mit /set editor festgelegt. Wenn kein Editor festgelegt wird, werden\ndie folgenden Umgebungsvariablen in der folgenden Reihenfolge gepr\u00FCft: JSHELLEDITOR, VISUAL\nund EDITOR. Wenn kein Editor und auch keine der Editorumgebungsvariablen festgelegt wurde,\nwird ein einfacher Editor gestartet.\n\n/edit <Name>\n\tBearbeitet die Snippets mit den angegebenen Namen (aktive Snippets werden bevorzugt aufgef\u00FChrt)\n\n/edit <ID>\n\tBearbeitet das Snippet mit der angegebenen Snippet-ID.\n\tEs k\u00F6nnen mehrere IDs oder ID-Bereiche verwendet werden, siehe "/help id"\n\n/edit -start\n\tBearbeitet die Start-Snippets. Vorgenommene \u00C4nderungen gelten nur f\u00FCr diese Session und\n\twirken sich nicht auf die Starteinstellung aus\n\n/edit -all\n\tBearbeitet alle Snippets, einschlie\u00DFlich aller nicht erfolgreichen, \u00FCberschriebenen, gel\u00F6schten und Start-Snippets\n\n/edit\n\tBearbeitet das derzeit aktive Code-Snippet, das Sie eingegeben oder mit /open eingelesen haben

help.drop.summary = L\u00F6scht einen Quelleintrag
help.drop.args = <Name oder ID>
help.drop =L\u00F6scht ein Snippet (deaktiviert es).\n\n/drop <Name>\n\tL\u00F6scht das Snippet mit dem angegebenen Namen\n\n/drop <ID>\n\tL\u00F6scht das Snippet mit der angegebenen Snippet-ID.\n\tEs k\u00F6nnen mehrere IDs oder ID-Bereiche verwendet werden, siehe "/help id"

help.save.summary = Speichert die Snippet-Quelle in einer Datei
help.save.args = [-all|-history|-start] <Datei>
help.save =Speichert die angegebenen Snippets und/oder Befehle in der angegebenen Datei.\n\n/save <Datei>\n\tSpeichert die Quelle derzeit aktiver Snippets in der Datei.\n\n/save -all <Datei>\n\tSpeichert die Quelle aller Snippets in der Datei.\n\tUmfasst die Quelle von \u00FCberschriebenem, nicht erfolgreichem und Startcode\n\n/save -history <Datei>\n\tSpeichert die sequenzielle Historie aller Befehle und Snippets, die seit dem\n\tStart des JShell-Tools eingegeben wurden.\n\n/save -start <Datei>\n\tSpeichert die aktuellen Startdefinitionen in der Datei\n\n/save <ID> <Datei>\n\tSpeichert das Snippet mit der angegebenen Snippet-ID.\n\tEs k\u00F6nnen mehrere IDs oder ID-Bereiche verwendet werden, siehe "/help id"

help.open.summary = \u00D6ffnet eine Datei als Quelleingabe
help.open.args = <Datei>
help.open =\u00D6ffnet eine Datei und liest deren Inhalt als Snippets und Befehle.\n\n/open <Datei>\n\tLiest die angegebene Datei als JShell-Tooleingabe.\n\nDie <Datei> kann der Name einer Betriebssystemdatei oder einer der folgenden vordefinierten\nDateinamen sein: DEFAULT, PRINTING oder JAVASE.\nHierbei handelt es sich jeweils um: die Standardimport-Snippets (wie von -default verwendet),\nDefinitionen der Methoden-Snippets print(), println() und printf() bzw.\nImporte aller Java SE-Packages.\n

help.vars.summary = Listet die deklarierten Variablen und ihre zugeh\u00F6rigen Werte auf
help.vars.args = [<Name oder ID>|-all|-start]
help.vars =Listet den Typ, Namen und Wert der eingegebenen Variablen auf.\n\n/vars\n\tListet den Typ, Namen und Wert der derzeit aktiven Variablen auf\n\n/vars <Name>\n\tListet Variablen mit dem angegebenen Namen auf (aktive Variablen werden bevorzugt aufgef\u00FChrt)\n\n/vars <ID>\n\tListet die Variable mit der angegebenen Snippet-ID auf.\n\tEs k\u00F6nnen mehrere IDs oder ID-Bereiche verwendet werden, siehe "/help id"\n\n/vars -start\n\tListet die Variablen in den ausgewerteten Start-Snippets auf\n\n/vars -all\n\tListet alle Variablen auf, einschlie\u00DFlich aller nicht erfolgreichen, \u00FCberschriebenen, gel\u00F6schten und Startvariablen

help.methods.summary = Listet die deklarierten Methoden und ihre zugeh\u00F6rigen Signaturen auf
help.methods.args = [<Name oder ID>|-all|-start]
help.methods =Listet den Namen, die Parametertypen und den R\u00FCckgabetyp der eingegebenen Methoden auf.\n\n/methods\n\tListet den Namen, die Parametertypen und den R\u00FCckgabetyp der derzeit aktiven Methoden auf\n\n/methods <Name>\n\tListet die Methoden mit dem angegebenen Namen auf (aktive Methoden werden bevorzugt aufgef\u00FChrt)\n\n/methods <ID>\n\tListet die Methode mit der angegebenen Snippet-ID auf.\n\tEs k\u00F6nnen mehrere IDs oder ID-Bereiche verwendet werden, siehe "/help id"\n\n/methods -start\n\tListet die Methoden in den ausgewerteten Start-Snippets auf\n\n/methods -all\n\tListet alle Snippets auf, einschlie\u00DFlich aller nicht erfolgreichen, \u00FCberschriebenen, gel\u00F6schten und Start-Snippets

help.types.summary = Listet die Typdeklarationen auf
help.types.args =[<Name oder ID>|-all|-start]
help.types =Listet eingegebene Klassen und Schnittstellen auf.\n\n/types\n\tListet die derzeit aktiven Typdeklarationen auf\n\n/types <Name>\n\tListet die Typdeklarationen mit dem angegebenen Namen auf (aktive Snippets werden bevorzugt aufgef\u00FChrt)\n\n/types <ID>\n\tListet die Typdeklaration mit der angegebenen Snippet-ID auf.\n\tEs k\u00F6nnen mehrere IDs oder ID-Bereiche verwendet werden, siehe "/help id"\n\n/types -start\n\tListet die Typdeklarationen in den ausgewerteten Start-Snippets auf\n\n/types -all\n\tListet alle Typdeklarationen auf, einschlie\u00DFlich aller nicht erfolgreichen, \u00FCberschriebenen, gel\u00F6schten und Starttypdeklarationen

help.imports.summary = Listet die importierten Elemente auf
help.imports.args =
help.imports =Listet die derzeit aktiven Importe auf. Dies umfasst Importe aus\nStart-Snippets.

help.exit.summary = Beendet das JShell-Tool
help.exit.args =[<Snippet mit ganzzahligem Ausdruck>]
help.exit =Beendet das JShell-Tool. \u00C4nderungen werden nicht gespeichert.\nSpeichern Sie Ihre \u00C4nderungen, bevor Sie diesen Befehl ausf\u00FChren\n\n/exit\n\tBeendet das JShell-Tool. Der Beendigungsstatus ist null\n\n/exit <Snippet mit ganzzahligem Ausdruck>\n\tWertet das Snippet aus. Wenn das Snippet nicht erfolgreich oder kein ganzzahliger Ausdruck ist,\n\twird der Fehler angezeigt. Andernfalls wird das JShell-Tool mit dem\n\tAusdruckswert als Beendigungsstatus beendet

help.reset.summary = Setzt das JShell-Tool zur\u00FCck
help.reset.args = [-class-path <Pfad>] [-module-path <Pfad>] [-add-modules <Module>]...
help.reset =Setzt den Code und den Ausf\u00FChrungsstatus des JShell-Tools zur\u00FCck:\n\t* Der gesamte eingegebene Code geht verloren\n\t* Der Ausf\u00FChrungsstatus wird neu gestartet\n\t* Der Startcode wird erneut ausgef\u00FChrt\nSpeichern Sie Ihre \u00C4nderungen, bevor Sie diesen Befehl verwenden.\nDer /reset-Befehl akzeptiert Auswertungskontextoptionen, siehe:\n\n\t/help context\n

help.reload.summary = Setzt die relevante Historie (derzeitige oder vorherige) zur\u00FCck und gibt sie erneut wieder (-restore)
help.reload.args = [-restore] [-quiet] [-class-path <Pfad>] [-module-path <Pfad>]...
help.reload =Setzt den Code und den Ausf\u00FChrungsstatus des JShell-Tools zur\u00FCck und gibt anschlie\u00DFend jedes g\u00FCltige Snippet\nsowie alle /drop-Befehle in der Reihenfolge wieder, in der sie eingegeben wurden.\n\n/reload\n\tDient zum Zur\u00FCcksetzen und Wiedergeben der g\u00FCltigen Historie seit Starten des JShell-Tools bzw.\n\tseit Ausf\u00FChrung eines /reset- oder /reload-Befehls - je nachdem, was\n\tals Letztes erfolgt ist\n\n/reload -restore\n\tDient zum Zur\u00FCcksetzen und Wiedergeben der g\u00FCltigen Historie zwischen dem vorherigen und aktuellen\n\tStarten des JShell-Tools bzw. der Ausf\u00FChrung eines /reset-, /reload- oder /env-\n\tBefehls. Diese Wiedergabe kann somit zum Wiederherstellen einer vorherigen\n\tJShell-Toolsession verwendet werden\n\n/reload [-restore] -quiet\n\tMit dem Argument "-quiet" wird die Wiedergabe nicht angezeigt, etwaige Fehler\n\thingegen schon\n\nJeder der obigen Befehle akzeptiert Auswertungskontextoptionen, siehe:\n\n\t/help context\n\nBeispiel:\n\n\t/reload -add-modules com.greetings -restore

help.env.summary = Zeigt den Auswertungskonzept an oder \u00E4ndert ihn
help.env.args = [-class-path <Pfad>] [-module-path <Pfad>] [-add-modules <Module>] ...
help.env =Zeigt den Auswertungskontext an oder \u00E4ndert ihn. Der Auswertungskontext ist der Classpath,\nModulpfad usw.\n\n/env\n\tZeigt den Auswertungskontext als Kontextoptionen an\n\n/env [-class-path <Pfad>] [-module-path <Pfad>] [-add-modules <Module>] ...\n\tDurch Festlegen mindestens einer Option wird der Auswertungskontext festgelegt. Wenn Snippets\n\tdefiniert wurden, wird der Ausf\u00FChrungsstatus auf den neuen Auswertungskontext\n\tzur\u00FCckgesetzt, und die Snippets werden erneut wiedergegeben. Die Wiedergabe wird nicht \n\tangezeigt, etwaige Fehler hingegen schon. Dies entspricht:\n\n\t\t/reload -quiet ...\n\nWeitere Einzelheiten zu Auswertungskontextoptionen finden Sie unter:\n\n\t/help context\n\nBeispiel:\n\n\t/env -add-modules com.greetings

help.history.summary = Historie Ihrer Eingaben
help.history.args = [-all]
help.history =Zeigt die Historie der Snippet- und Befehlseingaben an.\n\n/history\n\tListet die Historie der Snippet- und Befehlseingaben seit Start des JShell-Tools auf\n\n/history -all\n\tListet die gesamte Historie der Snippet- und Befehlseingaben aus dieser und vorherigen Sessions auf

help.debug.summary = Schaltet Debugging des JShell-Tools um
help.debug.args = [0][r][g][f][c][d][e]
help.debug =Zeigt Debugginginformationen f\u00FCr die JShell-Toolimplementierung an.\n0: Debugging deaktiviert\nr: Debugging auf Toolebene aktiviert\ng: Allgemeines Debugging aktiviert\nf: Dateimanagerdebugging aktiviert\nc: Abschlussanalysedebugging aktiviert\nd: Abh\u00E4ngigkeitsdebugging aktiviert\ne: Ereignisdebugging aktiviert

help.help.summary = Ruft Informationen zur Verwendung des JShell-Tools ab
help.help.args = [<Befehl>|<Thema>]
help.help =Zeigt Informationen zur Verwendung des JShell-Tools an.\n/help\n\tListet die Befehle und Hilfethemen des JShell-Tools auf\n\n/help <Befehl>\n\tZeigt Informationen zum angegebenen Befehl an.\n\tNur die ersten paar Buchstaben des Befehls werden ben\u00F6tigt - bei mehr als einer\n\t\u00DCbereinstimmung wird jede einzelne angezeigt. Beispiel: /help /li\n\n/help <Thema>\n\tZeigt Informationen zu dem angegebenen Hilfethema an. Beispiel: /help intro

help.set.summary = Legt Konfigurationsinformationen fest
help.set.args = editor|start|feedback|mode|prompt|truncation|format ...
help.set =Legt die Konfigurationsinformationen f\u00FCr das JShell-Tool fest, darunter:\nden zu verwendenden externen Editor, die zu verwendenden Startdefinitionen, einen neuen Feedbackmodus,\nden Befehls-Prompt, den zu verwendenden Feedbackmodus oder das Ausgabeformat.\n\n/set editor [-wait] <Befehl> <optionales Argument>...\n\tGibt den Befehl an, der f\u00FCr den /edit-Befehl gestartet werden soll.\n\tDer <Befehl> ist eine betriebssystemabh\u00E4ngige Zeichenfolge\n\n/set start <Datei>\n\tDer Inhalt der angegebenen <Datei> wird zu den Standardstart-Snippets und -befehlen\n\n/set feedback <Modus>\n\tLegt den Feedbackmodus fest, der das angezeigte Feedback f\u00FCr eingegebene Snippets und Befehle beschreibt\n\n/set mode <Modus> [<alter Modus>] -command|-quiet|-delete\n\tErstellt oder aktualisiert einen benutzerdefinierten Feedbackmodus. Optional kann er auch von einem vorhandenen Modus kopiert werden\n\n/set prompt <Modus> "<Prompt>" "<Fortsetzungs-Prompt>"\n\tLegt die angezeigten Prompts f\u00FCr einen angegebenen Feedbackmodus fest\n\n/set truncation <Modus> <L\u00E4nge> <Selektor>...\n\tLegt die maximale L\u00E4nge eines angezeigten Wertes fest\n\n/set format <Modus> <Feld> "<Format>" <Selektor>...\n\tKonfiguriert einen Feedbackmodus durch Festlegen des Formats eines Feldes, wenn der Selektor \u00FCbereinstimmt\n\n/set indent <Anzahl>\n\tLegt die Anzahl der Leerzeichen fest, mit denen Snippets automatisch einger\u00FCckt werden sollen\n\n/set\n\tZeigt Editor-, Start- und Feedbackeinstellungen als /set-Befehle an.\n\tLassen Sie den festgelegten Wert weg, um die Einstellungen eines der oben genannten Befehle anzuzeigen\n\nUm weitere Informationen zu einem dieser Formate zu erhalten, verwenden Sie /help mit dem angegebenen Format.\nBeispiel:   /help /set format

help.quest.summary = Ruft Informationen zur Verwendung des JShell-Tools ab
help.quest.args = [<Befehl>|<Thema>]
help.quest =Zeigt Informationen zur Verwendung des JShell-Tools an (Abk\u00FCrzung f\u00FCr /help).\n/?\n\tZeigt eine Liste der Befehle und Hilfethemen an\n/? <Befehl>\n\tZeigt Informationen zum angegebenen Befehl an.\n\tNur die ersten paar Buchstaben des Befehls werden ben\u00F6tigt - bei mehr als einer\n\t\u00DCbereinstimmung wird jeder einzelne angezeigt. Beispiel: /? /li\n\n/? <Thema>\n\tZeigt Informationen zu dem angegebenen Hilfethema an. Beispiel: /? intro

help.bang.summary = F\u00FChrt das letzte Snippet erneut aus, siehe: /help rerun
help.bang.args =
help.bang =Wertet das zuletzt eingegebene Snippet erneut aus.

help.slashID.summary = F\u00FChrt Snippets nach ID oder ID-Bereich erneut aus, siehe: /help rerun
help.slashID.args =
help.slashID =/<id> <id> <id>\n\n/<id>-<id>\n\nWertet die durch die ID oder den ID-Bereich angegebenen Snippets erneut aus.\nEin ID-Bereich wird als zwei per Bindestrich getrennte IDs dargestellt. Beispiel:  3-17\nStart- und Fehler-Snippets k\u00F6nnen verwendet werden. Beispiel: s3-s9 oder e1-e4\nEs k\u00F6nnen beliebig viele IDs oder ID-Bereiche verwendet werden. Beispiel: /3-7 s4 14-16 e2\nSiehe "/help id".

help.previous.summary = F\u00FChrt das n-te vorherige Snippet erneut aus, siehe: /help rerun
help.previous.args =
help.previous =Wertet das n-te zuletzt eingegebene Snippet erneut aus.

help.intro.summary = Einf\u00FChrung in das JShell-Tool
help.intro =Mit dem JShell-Toll k\u00F6nnen Sie Java-Code ausf\u00FChren und umgehend Ergebnisse erhalten.\nSie k\u00F6nnen eine Java-Definition (Variable, Methode, Klasse usw.) wie int x = 8,\neinen Java-Ausdruck wie x + x,\neine Java-Anweisung oder einen Java-Import eingeben.\nDiese kleinen Java-Code-Chunks werden als "Snippets" bezeichnet.\n\nAu\u00DFerdem stehen Ihnen die JShell-Toolbefehle zur Verf\u00FCgung, mit denen Sie Ihr Vorgehen\nbesser verstehen und steuern k\u00F6nnen. Beispiel: /list\n\nEine Liste der Befehle k\u00F6nnen Sie aufrufen mit: /help

help.keys.summary = Beschreibung der Readline-\u00E4hnlichen Eingabebearbeitung
help.keys =Das JShell-Tool bietet Unterst\u00FCtzung f\u00FCr Zeilenbearbeitung, damit Sie in Snippets\nund Befehlen navigieren und diese bearbeiten k\u00F6nnen. Sie k\u00F6nnen den aktuellen Befehl/das aktuelle Snippet bearbeiten\noder vorherige Befehle/Snippets aus der Historie abrufen, bearbeiten und ausf\u00FChren.\nDiese Unterst\u00FCtzung \u00E4hnelt Readline/Editline mit einfachen Emacs-\u00E4hnlichen Bindings.\nEs gibt auch f\u00FCr das JShell-Tool spezifische Schl\u00FCsselsequenzen.\n\nZeilen- und Historiennavigation:\n\n\tEingabetaste\n\t\tGibt das aktuelle Snippet ein\n\tNach-links-Taste oder Strg+B\n\t\tNavigiert ein Zeichen zur\u00FCck\n\tNach-rechts-Taste oder Strg+F\n\t\tNavigiert ein Zeichen vorw\u00E4rts\n\tNach-oben-Taste oder Strg+P\n\t\tNavigiert eine Zeile nach oben, r\u00FCckw\u00E4rts in der Historie\n\tNach-unten-Taste oder Strg+N\n\t\tNavigiert eine Zeile nach unten, vorw\u00E4rts in der Historie\n\tStrg+A\n\t\tNavigiert an den Anfang der Zeile\n\tStrg+E\n\t\tNavigiert an das Ende der Zeile\n\tMeta+B\n\t\tNavigiert ein Wort zur\u00FCck\n\tMeta+F\n\t\tNavigiert ein Wort vorw\u00E4rts\n\tStrg+R\n\t\tDurchsucht die Historie r\u00FCckw\u00E4rts\n\n\nEinfache Zeilen- und Historienbearbeitung:\n\n\tMeta+Eingabetaste oder Strg+Eingabetaste (je nach Plattform)\n\t\tF\u00FCgt eine neue Zeile in das Snippet ein\n\tStrg+_ (f\u00FCr Unterstrich kann Umschalttaste erforderlich sein) oder Strg+X gefolgt von Strg+U\n\t\tMacht \u00C4nderung r\u00FCckg\u00E4ngig. Wiederholen Sie die Eingabe, um weitere \u00C4nderungen r\u00FCckg\u00E4ngig zu machen\n\tEntf\n\t\tL\u00F6scht das Zeichen bei dem oder hinter dem Cursor, je nach Betriebssystem\n\tR\u00FCcktaste\n\t\tL\u00F6scht das Zeichen vor dem Cursor\n\tStrg+K\n\t\tL\u00F6scht den Text vom Cursor bis zum Ende der Zeile\n\tMeta+D\n\t\tL\u00F6scht den Text vom Cursor bis zum Ende des Wortes\n\tStrg+W\n\t\tL\u00F6scht den Text vom Cursor bis zum vorangegangenen Leerzeichen\n\tStrg+Y\n\t\tF\u00FCgt den zuletzt gel\u00F6schten Text in die Zeile ein\n\tMeta+Y\n\t\tNach Strg+Y durchl\u00E4uft Meta+Y den zuletzt gel\u00F6schten Text\n\tStrg+X gefolgt von Strg+K\n\t\tL\u00F6scht das gesamte Snippet\n\n\nTastenkombinationen f\u00FCr JShell-Tool:\n\n\tWeitere Einzelheiten k\u00F6nnen Sie aufrufen \u00FCber: /help shortcuts\n\n\tTab\n\t\tSchlie\u00DFt Java-ID oder JShell-Befehl ab\n\tUmschalt+Tab gefolgt von V\n\t\tKonvertiert den Ausdruck in eine Variablendeklaration\n\tUmschalt+Tab gefolgt von M\n\t\tKonvertiert die Anweisung in eine Methodendeklaration\n\tUmschalt+Tab gefolgt von I\n\t\tF\u00FCgt Importe f\u00FCr diese ID hinzu\n\t\n\nWeitere Zeilen- und Historienbearbeitung:\n\n\tStrg+L\n\t\tBereinigt den Bildschirm und gibt das Snippet erneut aus\n\tStrg+U\n\t\tL\u00F6scht die gesamte Zeile\n\tStrg+T\n\t\tTransponiert Zeichen\n\tStrg+X gefolgt von Strg+B\n\t\tNavigiert zur entsprechenden Klammer, eckigen Klammer, ...\n\tStrg+X gefolgt von =\n\t\tAktiviert den Modus zum Anzeigen der aktuellen Zeichenposition\n\tStrg+X gefolgt von Strg+O\n\t\tSchaltet um zwischen \u00DCberschreiben und Einf\u00FCgen von Zeichen\n\tMeta+C\n\t\tSetzt Anfangsbuchstaben eines Wortes in Gro\u00DFbuchstaben\n\tMeta+U\n\t\tKonvertiert ein Wort in Gro\u00DFbuchstaben\n\tMeta+L\n\t\tKonvertiert ein Wort in Kleinbuchstaben\n\tMeta+0 bis Meta+9 gefolgt von Taste\n\t\tWiederholt den Vorgang die angegebene Anzahl von Malen\n\nDabei gilt z.B.: "Strg+A" bedeutet, dass Sie die Steuerungstaste gedr\u00FCckt halten und A dr\u00FCcken.\nAuf vielen Tastaturen ist die Taste "Meta" gleichbedeutend mit der Taste "Alt".\nUnterst\u00FCtzung f\u00FCr Zeilenbearbeitung wird von JLine 3 abgeleitet.

help.shortcuts.summary = Beschreibung der Tastenanschl\u00E4ge f\u00FCr Snippet- und Befehlsabschluss,\nZugriff auf Informationen und automatische Codegenerierung
help.shortcuts =Unterst\u00FCtzte Tastenkombinationen:\n\n\tTab\n\t\tDr\u00FCcken Sie nach Eingabe der ersten paar Buchstaben einer Java-ID,\n\t\teines JShell-Toolbefehls oder, in einigen F\u00E4llen, eines JShell-\n\t\tToolbefehlsarguments die Tabulatortaste, um die Eingabe abzuschlie\u00DFen.\n\t\tWenn mehrere Abschl\u00FCsse vorhanden sind, werden m\u00F6gliche Abschl\u00FCsse\n\t\tangezeigt.\n\t\tDurch erneutes Dr\u00FCcken der Tabulatortaste wird Dokumentation angezeigt, sofern vorhanden und relevant.\n\n\tUmschalt+Tab gefolgt von V\n\t\tHalten Sie nach einem abgeschlossenen Ausdruck die Umschalttaste gedr\u00FCckt,\n\t\tund dr\u00FCcken Sie die Tabulatortaste. Lassen Sie dann los, und dr\u00FCcken Sie die Taste V.\n\t\tDer Ausdruck wird in eine Variablendeklaration konvertiert, \n\t\tderen Typ auf dem Typ des Ausdrucks basiert.\n\n\tUmschalt+Tab gefolgt von M\n\t\tHalten Sie nach Abschluss eines Ausdrucks oder einer Anweisung die\n\t\tUmschalttaste gedr\u00FCckt, und dr\u00FCcken Sie die Tabulatortaste. Lassen Sie dann los, und dr\u00FCcken\n\t\tSie die Taste M. Der Ausdruck bzw. die Anweisung wird in eine\n\t\tMethodendeklaration konvertiert. Bei einem Ausdruck basiert der\n\t\tR\u00FCckgabetyp der Methode auf dem Typ des Ausdrucks.\n\n\tUmschalt+Tab gefolgt von I\n\t\tHalten Sie nach einer nicht aufl\u00F6sbaren ID die Umschalttaste gedr\u00FCckt,\n\t\tund dr\u00FCcken Sie die Tabulatortaste. Lassen Sie dann los, und dr\u00FCcken Sie die Taste I.\n\t\tDas JShell-Tool schl\u00E4gt daraufhin m\u00F6gliche Importe vor, die die\n\t\tID basierend auf dem Inhalt des angegebenen Classpath aufl\u00F6sen werden.\n\t\tGeben Sie die Ziffer ein, die dem gew\u00FCnschten Import entspricht,\n\t\toder dr\u00FCcken Sie die Taste 0, um keine Importe hinzuzuf\u00FCgen.\n\nInformationen zu weiteren Sondertasten k\u00F6nnen Sie aufrufen durch: /help keys

help.context.summary = Beschreibung der Auswertungskontextoptionen f\u00FCr /env /reload und /reset
help.context =Mit diesen Optionen wird der Auswertungskontext konfiguriert. Sie k\u00F6nnen beim Starten des \nJShell-Tools in der Befehlszeile oder beim Neustarten des JShell-Tools mit den Befehlen\n/env, /reload oder /reset als Befehlsoptionen angegeben werden.\n\nSie lauten:\n\t--class-path <Pfad>\n\t\tDer <Pfad> ist eine Liste von Verzeichnissen, JAR-Archiven\n\t\tund ZIP-Archiven, die nach Klassendateien durchsucht werden sollen.\n\t\tVerwenden Sie unter Windows ein Semikolon (;), um Elemente im Pfad\n\t\tzu trennen. Verwenden Sie auf anderen Plattformen einen Doppelpunkt (:), um Elemente zu trennen.\n\t--module-path <Pfad>...\n\t\tDer <Pfad> ist eine Liste von Verzeichnissen, JAR-Archiven\n\t\tund ZIP-Archiven, die nach Modulen durchsucht werden sollen.\n\t\tVerwenden Sie unter Windows ein Semikolon (;), um Elemente im Pfad\n\t\tzu trennen. Verwenden Sie auf anderen Plattformen einen Doppelpunkt (:), um Elemente zu trennen.\n\t--add-modules <Modulname>[,<Modulname>...]\n\t\tRoot-Module, die zus\u00E4tzlich zum Ausgangsmodul aufgel\u00F6st werden sollen.\n\t\t<Modulname> kann auch ALL-DEFAULT, ALL-SYSTEM,\n\t\tALL-MODULE-PATH sein.\n\t--add-exports <Modul>/<Package>=<Zielmodul>(,<Zielmodul>)*\n\t\taktualisiert <Modul>, um <Package> in <Zielmodul> zu exportieren,\n\t\tunabh\u00E4ngig von der Moduldeklaration.\n\t\t<Zielmodul> kann ALL-UNNAMED sein, um in alle unbenannten\n\t\tModule zu exportieren. Wenn in JShell das <Zielmodul> nicht angegeben\n\t\twird (no =), wird ALL-UNNAMED verwendet.\n\nAuswertungskontextoptionen, die in der Befehlszeile eingegeben oder mit einem vorherigen\n/reset-, /env- oder /reload-Befehl angegeben werden, werden beibehalten, es sei denn,\nes wird eine Option eingegeben, die die Einstellung au\u00DFer Kraft setzt.\n\nIn der Befehlszeile ben\u00F6tigen diese Optionen zwei Bindestriche. Beispiel: --module-path\nIn den JShell-Toolbefehlen k\u00F6nnen sie ein oder zwei Bindestriche aufweisen. Beispiel: -module-path

help.id.summary = Beschreibung der Snippet-IDs und deren Verwendung
help.id =Jedes eingegebene Code-Snippet hat eine eindeutige Snippet-ID. Auch wenn Sie\ndasselbe Snippet erneut eingeben, erh\u00E4lt es eine neue ID. Bei normalen Snippets ist die ID\neine aufsteigende Zahl. Snippets, die mit einem Fehler nicht erfolgreich verlaufen, haben eine\nmit "e" beginnende Snippet-ID. Start-Snippets haben eine mit "s" beginnende ID.\n\nEine Snippet-ID stellt eine der M\u00F6glichkeiten dar, in einem Befehl auf ein Snippet zu verweisen. Beispiel:\nMit dem folgenden Befehl wird das Snippet mit der ID "14" gel\u00F6scht:\n\n\t/drop 14\n\nMit dem Befehl "/list" zeigen Sie die ID eines oder mehrerer Snippets an. Um die ID\naller Snippets anzuzeigen, einschlie\u00DFlich aller nicht erfolgreichen, \u00FCberschriebenen und Start-Snippets,\nverwenden Sie den Befehl "/list -all".\n\nSie k\u00F6nnen auch auf einen ID-Bereich verweisen, indem Sie die Anfangs-ID und die End-ID mit einem\nBindestrich trennen. Beispiel: "1-4" entspricht "1 2 3 4". F\u00FCr alle Befehle,\ndie auf Snippets verweisen, kann eine Liste mit IDs, ID-Bereichen und Snippet-Namen\nals Argumenten angegeben werden. Diese Befehle sind: /list, /edit, /drop, /save, /vars, /methods,\n/types und /<id>. Einige Beispiele:\n\n\t/edit 7-23\n\n\t/save s1-s4 3-8 foo 12 myfile\n\n\t/9-12 33\n\nSiehe "/help /edit", "/help /save" bzw. "/help rerun".

help.rerun.summary = Beschreibung von M\u00F6glichkeiten zur erneuten Auswertung zuvor eingegebener Snippets
help.rerun =Es gibt vier M\u00F6glichkeiten zur erneuten Auswertung zuvor eingegebener Snippets.\nDas letzte Snippet kann erneut ausgewertet werden mit: /!\nDas n-te vorherige Snippet kann mit Schr\u00E4gstrich-Minus und der jeweiligen Ziffer f\u00FCr n erneut ausgewertet werden. Beispiel: /-4\nBeispiel:\n\n\tjshell> 2 + 2\n\t$1 ==> 4\n\n\tjshell> /!\n\t2 + 2\n\t$2 ==> 4\n\n\tjshell> int z\n\tz ==> 0\n\n\tjshell> /-1\n\tint z;\n\tz ==> 0\n\n\tjshell> /-4\n\t2 + 2\n\t$5 ==> 4\n\nDie erneut auszuwertenden Snippets k\u00F6nnen per Snippet-ID oder ID-Bereich angegeben werden.\nEin ID-Bereich wird als zwei durch Bindestrich getrennte IDs dargestellt. Beispiel: 3-17\nEs k\u00F6nnen auch Start- und Fehler-Snippets verwendet werden. Beispiel: s3-s9 oder e1-e4\nEs k\u00F6nnen beliebig viele IDs oder ID-Bereiche verwendet werden. Beispiel: /3-7 s4 14-16 e2\nSiehe auch "/help id".\n\nAu\u00DFerdem k\u00F6nnen Sie die Historie auch r\u00FCckw\u00E4rts durchsuchen, indem Sie Strg+R gefolgt von der zu suchenden Zeichenfolge eingeben.

help.set._retain = Mit der Option "-retain" wird eine Einstellung zur Verwendung in zuk\u00FCnftigen Sessions gespeichert.\nDie -retain-Option kann f\u00FCr die folgenden Formen von /set verwendet werden:\n\n\t/set editor -retain\n\t/set start -retain\n\t/set feedback -retain\n\t/set mode -retain\n\nWeitere Einzelheiten zu diesen Befehlen - Beispiel: /help /set editor

help.set.format.summary = Legt das Format zum Melden eines Snippet-Ereignisses fest

help.set.format = Legt das Format zum Melden eines Snippet-Ereignisses fest:\n\n\t/set format <Modus> <Feld> "<Format>" <Selektor>...\n\nZeigt Formateinstellungen an:\n\n\t/set format [<Modus> [<Feld>]]\n\nDabei gilt: <Modus> ist der Name eines zuvor definierten Feedbackmodus - siehe "/help /set mode".\n<Feld> ist der Name des zu definierenden kontextspezifischen Formats.\n<Format> ist eine in Anf\u00FChrungszeichen gesetzte Zeichenfolge, die zum Wert des Feldes wird, wenn einer der\nSelektoren \u00FCbereinstimmt (oder keine Selektoren vorhanden sind). Bei Verwendung dieses Formats\nwerden in geschweiften Klammern eingeschlossene Feldnamen durch den Wert des Feldes zu diesem\nZeitpunkt ersetzt. Diese Felder k\u00F6nnen zuvor mit diesem Befehl definiert worden sein oder k\u00F6nnen\neines der folgenden vordefinierten, kontextspezifischen Felder sein:\n\t{name}       == Der Name. Beispiel: Variablenname, ...\n\t{type}       == Der Typname. Der Typ einer Variablen oder eines Ausdrucks, die\n\t\t\tParametertypen einer Methode\n\t{value}      == Der Ergebniswert eines Ausdrucks oder einer Variableninitialisierung\n\t{unresolved} == Die Liste nicht aufgel\u00F6ster Referenzen\n\t{errors}     == Die Liste behebbarer Fehler (nur w\u00E4hrend der Verarbeitung\n\t\t\tdes Feldes "display")\n\t{err}        == Eine nicht formatierte Fehlerzeile (nur w\u00E4hrend der Verarbeitung\n\t\t\tdes Feldes "errorline")\nZur Bestimmung des angezeigten Feedbacks greift das Tool auf folgende Felder zu:\n\t{display}    == Die angezeigte Meldung f\u00FCr ein Snippet-Ereignis\n\t{errorline}  == Das Format einer Fehlerzeile im Feld "errors"\n\t{pre}        == Das Feedbackpr\u00E4fix (am Beginn des Befehlsfeedbacks)\n\t{post}       == Das Feedback-Postfix (am Ende des Befehlsfeedbacks)\n\t{errorpre}   == Das Fehlerpr\u00E4fix (am Beginn des Fehlerfeedbacks)\n\t{errorpost}  == Das Fehler-Postfix (am Ende des Fehlerfeedbacks)\nDiese Fehler haben Standardeinstellungen (die \u00FCberschrieben werden k\u00F6nnen).\nDabei gilt: <Selektor> ist der Kontext, in dem das Format angewendet wird.\nDie Struktur des Selektors besteht aus einer durch Bindestriche getrennten Liste der Selektortyplisten.\nEine Selektortypliste ist eine durch Kommas getrennte Liste der Werte eines Selektortyps.\nEin Selektor stimmt \u00FCberein, wenn jede Selektortypliste \u00FCbereinstimmt. Eine Selektortypliste\nstimmt \u00FCberein, wenn einer der Werte \u00FCbereinstimmt.\n\nDer case-Selektortyp beschreibt die Art des Snippets. Die Werte lauten:\n\timport     -- Importdeklaration\n\tclass      -- Klassendeklaration\n\tinterface  -- Schnittstellendeklaration\n\tenum       -- Enum-Deklaration\n\tannotation -- Annotationsschnittstellendeklaration\n\trecord     -- Datensatzdeklaration\n\tmethod     -- Methodendeklaration -- Hinweis: {type}==parameter-types\n\tvardecl    -- Variablendeklaration ohne Initialisierung\n\tvarinit    -- Variablendeklaration mit Initialisierung\n\texpression -- Ausdruck -- Hinweis: {name}==Scratch-Variablenname\n\tvarvalue   -- Variablenwertausdruck\n\tassignment -- Variablenzuweisung\n\tstatement  -- Anweisung\nDer action-Selektortyp beschreibt, welcher Vorgang an dem Snippet vorgenommen wurde. Die Werte lauten:\n\tadded     -- Snippet wurde hinzugef\u00FCgt\n\tmodified  -- Ein vorhandenes Snippet wurde ge\u00E4ndert\n\treplaced  -- Ein vorhandenes Snippet wurde durch ein neues Snippet ersetzt\n\toverwrote -- Ein vorhandenes Snippet wurde \u00FCberschrieben\n\tdropped   -- Snippet wurde gel\u00F6scht\n\tused      -- Snippet wurde verwendet, wo es nicht zul\u00E4ssig war\nDer when-did-it-occur-Selektortyp beschreibt, ob es sich um eine direkte oder indirekte Aktion handelt. Die Werte lauten:\n\tprimary -- Das eingegebene Snippet\n\tupdate  -- Ein Update eines abh\u00E4ngigen Snippets\nDer resolution-state-Selektortyp beschreibt den Aufl\u00F6sungs-/Definitionsstatus des Snippets. Die Werte lauten:\n\tok         -- Korrekt aufgel\u00F6st\n\tdefined    -- Trotz \
behebbarer nicht aufgel\u00F6ster Referenzen definiert\n\tnotdefined -- Aufgrund behebbarer nicht aufgel\u00F6ster Referenzen nicht definiert\nDer unresolved-count-Selektortyp beschreibt die Anzahl nicht aufgel\u00F6ster Referenzen. Die Werte lauten:\n\tunresolved0 -- Es sind keine nicht aufgel\u00F6sten Namen vorhanden\n\tunresolved1 -- Es ist ein nicht aufgel\u00F6ster Name vorhanden\n\tunresolved2 -- Es sind mindestens zwei nicht aufgel\u00F6ste Namen vorhanden\nDer errors-count-Selektortyp beschreibt die Anzahl der Fehler. Die Werte lauten:\n\terror0 -- Keine Fehler\n\terror1 -- Ein Fehler\n\terror2 -- Mindestens zwei Fehler\n\nBeispiele:\n\t/set format mymode action 'Erstellt' added-primary\n\t/set format mymode action 'Update ersetzt' replaced-update\n\t/set format mymode display '{pre}{action} Klasse {name}{post}' class-ok\n\t/set format mymode display '{pre}{action} Variable {name}, auf Null zur\u00FCckgesetzt{post}' replaced-vardecl,varinit-ok-update\n\nNachfolgende Selektoren f\u00FCr ein Feld k\u00F6nnen einige oder alle zuvor verwendeten Selektoren \u00FCberschreiben - "last one wins"-Prinzip\n\nBei fehlender Angabe von <Format> werden die aktuellen Formateinstellungen angezeigt.\nBei Angabe von <Modus> werden nur die Formateinstellungen f\u00FCr diesen Modus angezeigt.\nBei Angabe von sowohl <Modus> als auch <Feld> werden nur die Formateinstellungen f\u00FCr\ndiesen Modus und dieses Feld angezeigt. Beispiel:\n\t/set format mymode\nzeigt die Formateinstellungen f\u00FCr den Modus "mymode" an\n

help.set.truncation.summary = Legt die maximale L\u00E4nge eines angezeigten Wertes fest

help.set.truncation = Legt die maximale L\u00E4nge eines angezeigten Wertes fest:\n\n\t/set truncation <Modus> <L\u00E4nge> <Selektor>...\n\nAktuelle Abschneideeinstellungen anzeigen:\n\n\t/set truncation [<Modus>]\n\nHier gilt: <Modus> ist der Name eines zuvor definierten Feedbackmodus - siehe "/help /set mode".\n<L\u00E4nge> ist eine Ganzzahl ohne Vorzeichen, die eine Maximall\u00E4nge angibt.\n<Selektor> ist nur erforderlich, wenn Sie die Abschneidel\u00E4nge des Wertes nach Kontext\noptimieren m\u00F6chten. In diesem Fall ist <Selektor> der Kontext, in dem das Abschneiden angewendet wird.\nDie Struktur des Selektors besteht aus einer durch Bindestriche getrennten Liste der Selektortyplisten.\nEine Selektortypliste ist eine durch Kommas getrennte Liste der Werte eines Selektortyps.\nEin Selektor stimmt \u00FCberein, wenn jede Selektortypliste \u00FCbereinstimmt. Eine Selektortypliste\nstimmt \u00FCberein, wenn einer der Werte \u00FCbereinstimmt.\n\nNachfolgend sind die entsprechenden Selektortypen f\u00FCr das Abschneiden aufgelistet.\n\nDer case-Selektortyp beschreibt die Art des Snippets. Die Werte lauten:\n\tvardecl    -- Variablendeklaration ohne Initialisierung\n\tvarinit    -- Variablendeklaration mit Initialisierung\n\texpression -- Ausdruck -- Hinweis: {name}==Scratch-Variablenname\n\tvarvalue   -- Variablenwertausdruck\n\tassignment -- Variablenzuweisung\nDer action-Selektortyp beschreibt, welcher Vorgang an dem Snippet vorgenommen wurde. Die Werte lauten:\n\tadded     -- Snippet wurde hinzugef\u00FCgt\n\tmodified  -- Ein vorhandenes Snippet wurde ge\u00E4ndert\n\treplaced  -- Ein vorhandenes Snippet wurde durch ein neues Snippet ersetzt\nBeispiele:\n\t/set trunc mymode 80\n\t/set truncation mymode 45 expression\n\t/set truncation mymode 0 vardecl-modified,replaced\n\nNachfolgende Selektoren f\u00FCr ein Feld k\u00F6nnen einige oder alle zuvor verwendeten Selektoren \u00FCberschreiben - "last one wins"-Prinzip\n\nBei fehlender Angabe von <L\u00E4nge> werden die Abschneideeinstellungen angezeigt.\nBei Angabe von <Modus> werden nur die Abschneideeinstellungen f\u00FCr diesen Modus angezeigt.\nBeispiel:\n\t/set truncation mymode\nZeigt die Abschneideeinstellungen f\u00FCr den Modus "mymode" an\n

help.set.feedback.summary = Legt den Feedbackmodus mit einer Beschreibung des angezeigten Feedbacks f\u00FCr eingegebene Snippets und Befehle fest

help.set.feedback = Legt den Feedbackmodus mit einer Beschreibung des angezeigten Feedbacks f\u00FCr eingegebene Snippets und Befehle fest:\n\n\t/set feedback [-retain] <Modus>\n\nBeh\u00E4lt den aktuellen Feedbackmodus f\u00FCr zuk\u00FCnftige Sessions bei:\n\n\t/set feedback -retain\n\nZeigt den Feedbackmodus an und listet verf\u00FCgbare Modi auf:\n\n\t/set feedback\n\nDabei gilt: <Modus> ist der Name eines zuvor definierten Feedbackmodus.\nSie d\u00FCrfen nur gerade gen\u00FCgend Buchstaben verwenden, um den Namen eindeutig zu machen.\nBenutzerdefinierte Modi k\u00F6nnen hinzugef\u00FCgt werden, siehe "/help /set mode"\n\nBei Verwendung der -retain-Option wird diese Einstellung in dieser und zuk\u00FCnftigen\nAusf\u00FChrungen des JShell-Tools verwendet.\n\nBei fehlender Angabe von <Modus> oder -retain werden der aktuelle Feedbackmodus und verf\u00FCgbare Modi angezeigt.\n

help.set.mode.summary = Erstellt einen benutzerdefinierten Feedbackmodus (optional durch Kopieren aus einem vorhandenen Modus)

help.set.mode = Erstellt einen benutzerdefinierten Feedbackmodus (optional durch Kopieren aus einem vorhandenen Modus):\n\n\t/set mode <neuer Modus> [<alter Modus>] (-command|-quiet)\n\nBeh\u00E4lt einen benutzerdefinierten Feedbackmodus f\u00FCr zuk\u00FCnftige Sessions bei:\n\n\t/set mode -retain <Modus>\n\nL\u00F6scht einen benutzerdefinierten Feedbackmodus:\n\n\t/set mode -delete [-retain] <Modus>\n\nZeigt Feedbackmoduseinstellungen an:\n\n\t/set mode [<Modus>]\n\nDabei gilt: <neuer Modus> ist der Name des zu erstellenden Modus.\n<alter Modus> ist der Name eines vorhandenen Feedbackmodus.\n<Modus> ist der Name eines vorhandenen Feedbackmodus.\n\nBei Angabe von <alter Modus> werden die zugeh\u00F6rigen Einstellungen in den neuen Modus kopiert.\n\nDas Feedback, das ein Modus f\u00FCr eingegebene Snippets bereitstellt, wird von den "/set format"-Einstellungen\nbestimmt. F\u00FCr eingegebene Befehle ist das Feedback dagegen entweder aktiviert oder deaktiviert.\nDies wird durch die beim Erstellen des Modus verwendete Option bestimmt. Es muss entweder die Option "-command"\noder die Option "-quiet" angegeben werden. Bei Verwendung von "-command" wird im neuen Modus informatives\nund best\u00E4tigendes Befehlsfeedback angezeigt. Bei Verwendung von "-quiet" wird bei Befehlen\nnur erforderliches Feedback angegeben (z.B. Fehler).\n\nNach dem Erstellen des neuen Modus k\u00F6nnen Sie diesen mit "/set format", "/set prompt und "/set truncation"\nkonfigurieren. Verwenden Sie "/set feedback", um den neuen Modus zu verwenden.\n\nBei Verwendung der Option "-retain" (ohne Option "-delete") wird der Modus (einschlie\u00DFlich\ndes aktuellen Prompts, Formats und der Abschneideeinstellungen) zur Verwendung in\nzuk\u00FCnftigen Ausf\u00FChrungen des JShell-Tools gespeichert. Wenn "-retain" nicht verwendet wird, wird der Modus nur in\nder aktuellen Session definiert. Verwenden Sie "-retain" nach dem Aktualisieren der Moduseinstellungen erneut,\num die Updates session\u00FCbergreifend beizubehalten.\n\nWenn nur die Option "-delete" verwendet wird, wird der Modus aus der aktuellen Session gel\u00F6scht.\nWenn sowohl "-retain" als auch "-delete" verwendet werden, wird der Modus aus der aktuellen und aus\nzuk\u00FCnftigen Sessions gel\u00F6scht.\n\nBei fehlender Angabe von Optionen werden die Moduseinstellungen angezeigt.\nBei Angabe des <Modus> werden nur die Moduseinstellungen f\u00FCr diesen Modus angezeigt.\nHinweis: Die Einstellungen f\u00FCr den Modus umfassen die Einstellungen f\u00FCr Prompt, Format und\nAbschneiden.\nBeispiel:\n\t/set mode mymode\n\nZeigt Modus, Prompt, Format und Abschneideeinstellungen f\u00FCr den Modus "mymode" an

help.set.prompt.summary = Legt die Prompts fest

help.set.prompt = Legt die Prompts fest. Es m\u00FCssen sowohl der normale als auch der Fortsetzungs-Prompt festgelegt werden:\n\n\t/set prompt <mode> "<Prompt>" "<Fortsetzungs-Prompt>"\n\nZeigt den normalen und den Fortsetzungs-Prompt an:\n\n\t/set prompt [<Modus>]\n\nDabei gilt: <Modus> ist der Name eines zuvor definierten Feedbackmodus.\n<Prompt> und <Fortsetzungs-Prompt> sind in Anf\u00FChrungszeichen gesetzte Zeichenfolgen, die als Eingabe-Prompts ausgegeben werden.\nOptional k\u00F6nnen beide "%%s" enthalten. Dies wird durch die n\u00E4chste Snippet-ID ersetzt.\nDer Eingabe wird unter Umst\u00E4nden keine ID zugewiesen, wenn es sich z.B. um einen Fehler oder Befehl handelt.\nDer Fortsetzungs-Prompt wird in einem mehrzeiligen Snippet in der zweiten und allen nachfolgenden Zeilen verwendet.\n\nBei fehlender Angabe von <Prompt> werden die aktuell festgelegten Prompts angezeigt.\nBei Angabe des <Modus> werden nur die Prompts f\u00FCr diesen Modus angezeigt.\nBeispiel:\n\t/set prompt mymode\nZeigt die f\u00FCr den Modus "mymode" festgelegten Prompts an\n

help.set.editor.summary =Legt den mit dem /edit-Befehl zu startenden Befehl fest

help.set.editor =Legt den mit dem /edit-Befehl zu startenden Befehl fest:\n\n\t/set editor [-retain] [-wait] <Befehl>\n\n\t/set editor [-retain] -default\n\n\t/set editor [-retain] -delete\n\nBeh\u00E4lt die aktuelle Editoreinstellung f\u00FCr zuk\u00FCnftige Sessions bei:\n\n\t/set editor -retain\n\nZeigt den mit dem /edit-Befehl zu startenden Befehl an:\n\n\t/set editor\n\nDer <Befehl> ist eine betriebssystemabh\u00E4ngige Zeichenfolge.\nDer <Befehl> kann durch Leerzeichen getrennte Argumente (z.B. Kennzeichen) enthalten\n\nBei Angabe der Option -default wird der integrierte Standardeditor verwendet.\n\nBei Angabe der Option -delete werden vorherige Einstellungen ignoriert - die Editoreinstellungen\nwerden wie beim Starten des JShell-Tools initialisiert. Insbesondere wird eine eventuell vorhandene\nbeibehaltene Einstellung verwendet (es sei denn, es werden sowohl -retain als auch -delete angegeben - \nin diesem Fall wird die beibehaltene Einstellung gel\u00F6scht). Ist eine der folgenden Umgebungsvariablen festgelegt,\nwird sie verwendet: JSHELLEDITOR, VISUAL oder EDITOR (in dieser Reihenfolge). Andernfalls\nwird der integrierte Standardeditor verwendet.\n\nBei Angabe von <Befehl> wird dieser als externer Editor verwendet. Der <Befehl>\nbesteht aus dem Programm und null oder mehr Programmargumenten. Bei Verwendung von <Befehl>\nwird die zu bearbeitende tempor\u00E4re Datei als letztes Argument angeh\u00E4ngt.\nNormalerweise wird der Bearbeitungsmodus fortgesetzt, bis der externe Editor beendet wird. Einige externe Editoren\nwerden umgehend beendet (z.B. wenn das Bearbeitungsfenster vorhanden ist). Es m\u00FCssen entweder Kennzeichen\nf\u00FCr externe Editoren verwendet werden, um ein umgehendes Beenden zu verhindern, oder die Option -wait muss\nverwendet werden, um den Benutzer zur Angabe aufzufordern, wann der Bearbeitungsmodus beendet werden soll.\n\nHinweis: Bei aktivem Bearbeitungsmodus werden keine Befehlseingaben angezeigt. Nach Beenden des Bearbeitungsmodus\nwerden keine \u00C4nderungen an den bearbeiteten Snippets angezeigt.\n\nBei Verwendung der Option -retain wird die Einstellung in dieser und zuk\u00FCnftigen\nAusf\u00FChrungen des JShell-Tools verwendet.\n\nBei fehlender Angabe von <Befehl> oder Optionen wird die Editoreinstellung angezeigt.\n

help.set.start.summary =Legt die Startkonfiguration fest

help.set.start =Legt die Startkonfiguration fest - eine Abfolge aus Snippets und Befehlen, die beim Hochfahren gelesen werden:\n\n\t/set start [-retain] <Datei>...\n\n\t/set start [-retain] -default\n\n\t/set start [-retain] -none\n\nBeh\u00E4lt die Startkonfiguration f\u00FCr zuk\u00FCnftige Sessions bei:\n\n\t/set start -retain\n\nZeigt die Starteinstellung an:\n\n\t/set start\n\nDer Inhalt der angegebenen <Datei> wird zu den verwendeten Start-Snippets und -befehlen,\nwenn die Befehle /reset, /reload oder /env in dieser Session verwendet werden.\nWird stattdessen die Option -default angegeben, werden die vordefinierten Startimport-\nSnippets verwendet.\nBei Verwendung der Option -none sind die Starteinstellungen leer - es werden keine\nStart-Snippets oder -befehle verwendet.\nDieser Befehl eignet sich gut zum Testen der Starteinstellungen. Um sie f\u00FCr zuk\u00FCnftige\nAusf\u00FChrungen des JShell-Tools beizubehalten, verwenden Sie den Befehl:\n\t/set start -retain\n\nBei Verwendung der Option -retain wird die Einstellung in dieser und zuk\u00FCnftigen\nAusf\u00FChrungen des JShell-Tools verwendet.\n\nBei fehlender Angabe von <Datei> oder Optionen werden die Starteinstellungen angezeigt.\nHinweis: Wenn der Start zuletzt von einer Datei festgelegt wurde, wird dies mit dem\nBefehl "set start" gefolgt vom Inhalt der Datei angezeigt.\n\nDie <Datei> kann der Name einer Betriebssystemdatei oder einer der vordefinierten\nStartdateinamen sein: DEFAULT, PRINTING oder JAVASE.\nHierbei handelt es sich jeweils um: die Standardimport-Snippets (wie von -default verwendet),\nDefinitionen der Methoden-Snippets print(), println() und printf() bzw.\nImporte aller Java SE-Packages.\nEs kann mehr als eine <Datei> angegeben werden. Beispiel:\n\n\t/set start -retain DEFAULT PRINTING

help.set.indent.summary =Gibt die Anzahl der Leerzeichen zum Einr\u00FCcken der Snippets an

help.set.indent =Gibt die Anzahl der Leerzeichen zum Einr\u00FCcken der Snippets an:\n\n\t/set indent <Anzahl>\n\nZeigt die Einzugseinstellung an:\n\n\t/set indent\n
startup.feedback = /set mode verbose -command    \n\n/set prompt verbose '\\njshell> '   '   ...> '    \n\n/set format verbose pre '|  '    \n/set format verbose post '%n'    \n/set format verbose errorpre '|  '    \n/set format verbose errorpost '%n'    \n\n/set format verbose errorline '{post}{pre}    {err}'    \n\n/set format verbose action 'Erstellt' added-primary    \n/set format verbose action 'Ge\u00E4ndert' modified-primary    \n/set format verbose action 'Ersetzt' replaced-primary    \n/set format verbose action '\u00DCberschrieben' overwrote-primary    \n/set format verbose action 'Gel\u00F6scht' dropped-primary    \n/set format verbose action '  Update erstellt' added-update    \n/set format verbose action '  Update ge\u00E4ndert' modified-update    \n/set format verbose action '  Update ersetzt' replaced-update    \n/set format verbose action '  Update \u00FCberschrieben' overwrote-update    \n/set format verbose action '  Update gel\u00F6scht' dropped-update    \n\n/set format verbose until ', Instanziierung oder Aufruf der zugeh\u00F6rigen Methoden ist jedoch nicht m\u00F6glich bis'   defined-class,record-primary    \n/set format verbose until ', Aufruf der zugeh\u00F6rigen Methoden ist jedoch nicht m\u00F6glich bis'                      defined-interface-primary    \n/set format verbose until ', Verwendung ist jedoch nicht m\u00F6glich bis'                                  defined-enum,annotation-primary    \n/set format verbose until ', Aufruf ist jedoch nicht m\u00F6glich bis'                               defined-method-primary    \n/set format verbose until ', Referenzierung ist jedoch nicht m\u00F6glich bis'                            notdefined-primary    \n/set format verbose until ' Instanziierung oder Aufruf der zugeh\u00F6rigen Methoden ist nicht m\u00F6glich bis'          defined-class,record-update    \n/set format verbose until ' Aufruf der zugeh\u00F6rigen Methoden ist nicht m\u00F6glich bis'                              defined-interface-update    \n/set format verbose until ' Aufruf ist nicht m\u00F6glich bis'                                      defined-method-update    \n/set format verbose until ' Referenzierung ist nicht m\u00F6glich bis'                                   notdefined-update    \n\n/set format verbose unrerr '{unresolved} ist deklariert'                                           unresolved1-error0    \n/set format verbose unrerr '{unresolved} sind deklariert'                                          unresolved2-error0    \n/set format verbose unrerr ' dieser Fehler ist behoben: {errors}'                                 unresolved0-error1    \n/set format verbose unrerr '{unresolved} ist deklariert, und dieser Fehler ist behoben: {errors}'     unresolved1-error1    \n/set format verbose unrerr '{unresolved} sind deklariert, und dieser Fehler ist behoben: {errors}'    unresolved2-error1    \n/set format verbose unrerr ' diese Fehler sind behoben: {errors}'                              unresolved0-error2    \n/set format verbose unrerr '{unresolved} ist deklariert, und diese Fehler sind behoben: {errors}'  unresolved1-error2    \n/set format verbose unrerr '{unresolved} sind deklariert, und diese Fehler sind behoben: {errors}' unresolved2-error2    \n\n/set format verbose resolve '{until}{unrerr}'                                                   defined,notdefined-added,modified,replaced,used    \n\n/set format verbose typeKind 'Klasse'                  class    \n/set format verbose typeKind 'Schnittstelle'              interface    \n/set format verbose typeKind 'Enum'                   enum    \n/set format verbose typeKind 'Annotationsschnittstelle'   annotation    \n/set format verbose typeKind 'Datensatz'                 record    \n\n/set format verbose result '{name} ==> {value}{post}'                                        added,modified,replaced-ok-primary    \n\n/set format verbose display '{result}{pre}Scratch-Variable {name} erstellt: {type}{post}'    \
expression-added,modified,replaced-primary    \n/set format verbose display '{result}{pre}Wert von {name}: {type}{post}'                    varvalue-added,modified,replaced-primary    \n/set format verbose display '{result}{pre}Zugewiesen zu {name}: {type}{post}'                 assignment-primary    \n/set format verbose display '{result}{pre}{action} Variable {name}: {type}{resolve}{post}'  varinit,vardecl    \n/set format verbose display '{pre}{action} Variable {name}{resolve}{post}'                   vardecl,varinit-notdefined    \n/set format verbose display '{pre}{action} Variable {name}{post}'                            dropped-vardecl,varinit,expression    \n/set format verbose display '{pre}{action} Variable {name}, auf Null zur\u00FCckgesetzt{post}'             replaced-vardecl,varinit-ok-update    \n\n/set format verbose display '{pre}{action} {typeKind} {name}{resolve}{post}'                 class,interface,enum,annotation,record    \n/set format verbose display '{pre}{action} Methode {name}({type}){resolve}{post}'             method    \n\n/set format verbose display '{pre}Verwendung von {typeKind} {name} wurde versucht{resolve}{post}'         used-class,interface,enum,annotation,record    \n/set format verbose display '{pre}Aufruf der Methode {name} ({type}) wurde versucht{resolve}{post}'    used-method    \n\n/set truncation verbose 80\n/set truncation verbose 1000                                                                  varvalue,expression\n\n/set mode normal -command verbose    \n/set format normal display ''                                                               added,modified,replaced,overwrote,dropped-update    \n/set format normal display '{pre}{action} Variable {name}, auf Null zur\u00FCckgesetzt{post}'             replaced-vardecl,varinit-ok-update    \n/set format normal display '{pre}{action} Variable {name}{resolve}{post}'                   replaced-vardecl,varinit-notdefined    \n/set format normal display '{result}'                                                       added,modified,replaced-expression,varvalue,assignment,varinit,vardecl-ok-primary    \n/set mode concise -quiet normal    \n\n/set prompt concise 'jshell> '   '   ...> '    \n\n/set format concise display ''                                                              class,interface,enum,annotation,record,method,assignment,varinit,vardecl-ok    \n\n/set feedback normal    \n\n/set mode silent -quiet    \n/set prompt silent '-> ' '>> '    \n/set truncation silent 80\n/set truncation silent 1000                                                                  varvalue,expression\n/set format silent pre '|  '    \n/set format silent post '%n'    \n/set format silent errorpre '|  '    \n/set format silent errorpost '%n'    \n/set format silent display ''    \n
