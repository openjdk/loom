#
# Copyright (c) 1999, 2021, Oracle and/or its affiliates. All rights reserved.
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
#
# This code is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 2 only, as
# published by the Free Software Foundation.  Oracle designates this
# particular file as subject to the "Classpath" exception as provided
# by Oracle in the LICENSE file that accompanied this code.
#
# This code is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# version 2 for more details (a copy is included in the LICENSE file that
# accompanied this code).
#
# You should have received a copy of the GNU General Public License version
# 2 along with this work; if not, write to the Free Software Foundation,
# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
#
# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
# or visit www.oracle.com if you need additional information or have any
# questions.
#

# Messages in this file which use "placeholders" for values (e.g. {0}, {1})
# are preceded by a stylized comment describing the type of the corresponding
# values.
# The simple types currently in use are:
#
# annotation        annotation compound
# boolean           true or false
# diagnostic        a sub-message; see compiler.misc.*
# fragment          similar to 'message segment', but with more specific type
# modifier          a Java modifier; e.g. public, private, protected
# file              a file URL
# file object       a file URL - similar to 'file' but typically used for source/class files, hence more specific
# flag              a Flags.Flag instance
# name              a name, typically a Java identifier
# number            an integer
# option name       the name of a command line option
# path              a path
# profile           a profile name
# source            a source version number, such as 1.5, 1.6, 1.7, taken from a com.sun.tools.javac.code.Source
# source version    a source version number, such as 1.5, 1.6, 1.7, taken from a javax.lang.model.SourceVersion
# string            a general string
# symbol            the name of a declared type
# symbol kind       the kind of a symbol (i.e. method, variable)
# kind name         an informative description of the kind of a declaration; see compiler.misc.kindname.*
# target            a target version number, such as 1.5, 1.6, 1.7, taken from a com.sun.tools.javac.jvm.Target
# token             the name of a non-terminal in source code; see compiler.misc.token.*
# tree tag          the name of a non-terminal in source code; see compiler.misc.token.*
# type              a Java type; e.g. int, X, X<T>
# url               a URL
# object            a Java object (unspecified)
# unused            the value is not used in this message
#
# The following compound types are also used:
#
# collection of X   a comma-separated collection of items; e.g. collection of type
# list of X         a comma-separated list of items; e.g. list of type
# set of X          a comma-separated set of items; e.g. set of modifier
#
# These may be composed:
#
# list of type or message segment
#
# The following type aliases are supported:
#
# message segment --> diagnostic or fragment
# file name --> file, path or file object
#
# Custom comments are supported in parenthesis i.e.
#
# number (classfile major version)
#
# These comments are used internally in order to generate an enum-like class declaration containing
# a method/field for each of the diagnostic keys listed here. Those methods/fields can then be used
# by javac code to build diagnostics in a type-safe fashion.
#
# In addition, these comments are verified by the jtreg test test/tools/javac/diags/MessageInfo,
# using info derived from the collected set of examples in test/tools/javac/diags/examples.
# MessageInfo can also be run as a standalone utility providing more facilities
# for manipulating this file. For more details, see MessageInfo.java.

##
## errors
##

# 0: symbol
compiler.err.abstract.cant.be.instantiated={0} ist abstrakt, kann nicht instanziiert werden

compiler.err.abstract.meth.cant.have.body=Abstrakte Methoden k\u00F6nnen keinen Body enthalten

# 0: kind name, 1: symbol
compiler.err.already.annotated={0} {1} wurde bereits mit Annotation versehen

# 0: kind name, 1: symbol, 2: kind name, 3: symbol
compiler.err.already.defined={0} {1} ist bereits in {2} {3} definiert

# 0: kind name, 1: symbol, 2: kind name, 3: kind name, 4: symbol
compiler.err.already.defined.in.clinit={0} {1} ist bereits in {2} von {3} {4} definiert

# 0: symbol
compiler.err.already.defined.single.import=Es wurde bereits ein Typ mit demselben einfachen Namen durch den Einzeltypimport von {0} definiert

# 0: symbol
compiler.err.already.defined.static.single.import=Es wurde bereits ein Typ mit demselben einfachen Namen durch den statischen Einzeltypimport von {0} definiert

# 0: symbol
compiler.err.already.defined.this.unit={0} ist in dieser Kompilierungseinheit bereits definiert

# 0: type, 1: list of name
compiler.err.annotation.missing.default.value=In Annotation @{0} fehlt ein Standardwert f\u00FCr das Element "{1}"

# 0: type, 1: list of name
compiler.err.annotation.missing.default.value.1=In Annotation @{0} fehlen Standardwerte f\u00FCr Elemente {1}

# 0: type
compiler.err.annotation.not.valid.for.type=Annotation ist f\u00FCr Element des Typs {0} nicht g\u00FCltig

compiler.err.annotation.type.not.applicable=Annotationsschnittstelle ist f\u00FCr diese Art Deklaration nicht anwendbar

# 0: type
compiler.err.annotation.type.not.applicable.to.type=Annotation @{0} ist in diesem Typkontext nicht anwendbar

compiler.err.annotation.value.must.be.annotation=Annotationswert muss eine Annotation sein

compiler.err.annotation.value.must.be.class.literal=Annotationswert muss ein Klassenliteral sein

compiler.err.annotation.value.must.be.name.value=Annotationswerte m\u00FCssen das Format "Name=Wert" aufweisen

compiler.err.annotation.value.not.allowable.type=Annotationswert hat keinen zul\u00E4ssigen Typ

compiler.err.expression.not.allowable.as.annotation.value=Ausdruck ist als Annotationswert nicht zul\u00E4ssig

compiler.err.anon.class.impl.intf.no.args=Anonyme Klasse implementiert Schnittstelle. Argumente sind nicht m\u00F6glich

compiler.err.anon.class.impl.intf.no.typeargs=Anonyme Klasse implementiert Schnittstelle. Typargumente sind nicht m\u00F6glich

compiler.err.anon.class.impl.intf.no.qual.for.new=Anonyme Klasse implementiert Schnittstelle. Qualifier f\u00FCr "Neu" ist nicht m\u00F6glich

compiler.err.cant.inherit.from.anon=Erben aus anonymer Klasse nicht m\u00F6glich

# 0: symbol, 1: symbol, 2: symbol
compiler.err.array.and.varargs={0} und {1} k\u00F6nnen nicht beide in {2} deklariert werden

compiler.err.array.dimension.missing=Arraydimension fehlt

compiler.err.illegal.array.creation.both.dimension.and.initialization=Arrayerstellung mit Dimensionsausdruck und Initialisierung ist unzul\u00E4ssig

# 0: type
compiler.err.array.req.but.found=Array erforderlich, aber {0} gefunden

compiler.err.attribute.value.must.be.constant=Elementwert muss ein Konstantenausdruck sein

# 0: string (statement type)
compiler.err.bad.initializer=Ung\u00FCltiger Initializer f\u00FCr {0}

compiler.err.break.outside.switch.loop=Unterbrechung au\u00DFerhalb Switch oder Schleife

compiler.err.break.outside.switch.expression=Versuch, Vorgang aus einem Switch-Ausdruck zu unterbrechen

compiler.err.continue.outside.switch.expression=Versuch, Vorgang aus einem Switch-Ausdruck fortzusetzen

compiler.err.return.outside.switch.expression=Versuch, aus einem Switch-Ausdruck zur\u00FCckzukehren

compiler.err.rule.completes.normally=Switch-Regel wird ohne Angabe eines Wertes abgeschlossen\n(Switch-Regeln in Switch-Ausdr\u00FCcken m\u00FCssen einen Wert oder Throw angeben)

compiler.err.switch.expression.completes.normally=Switch-Ausdruck wird ohne Angabe eines Wertes abgeschlossen\n(Switch-Ausdr\u00FCcke m\u00FCssen einen Wert angeben oder einen Throw f\u00FCr alle m\u00F6glichen Eingabewerte ausgeben)

compiler.err.no.switch.expression ="yield" au\u00DFerhalb von Switch-Ausdruck

compiler.err.no.switch.expression.qualify="yield" au\u00DFerhalb von Switch-Ausdruck\n(um eine Methode namens "yield" aufzurufen, qualifizieren Sie den yield-Aufruf mit einem Empf\u00E4nger oder Typnamen)

compiler.err.invalid.yield=Ung\u00FCltige Verwendung der eingeschr\u00E4nkten ID "yield"\n(um eine Methode namens "yield" aufzurufen, qualifizieren Sie den yield-Aufruf mit einem Empf\u00E4nger oder Typnamen)

compiler.warn.invalid.yield="yield" kann in einem zuk\u00FCnftigen Release zu einer eingeschr\u00E4nkten ID werden\n(um eine Methode namens "yield" aufzurufen, qualifizieren Sie den yield-Aufruf mit einem Empf\u00E4nger oder Typnamen)

compiler.err.switch.expression.empty=Switch-Ausdruck enth\u00E4lt keine CASE-Klauseln

compiler.err.switch.expression.no.result.expressions=Switch-Ausdruck enth\u00E4lt keine Ergebnisausdr\u00FCcke

# 0: name
compiler.err.call.must.be.first.stmt.in.ctor=Aufruf von {0} muss die erste Anweisung im Konstruktor sein

# 0: symbol kind, 1: name, 2: list of type or message segment, 3: list of type or message segment, 4: symbol kind, 5: type, 6: message segment
compiler.err.cant.apply.symbol={0} {1} in {4} {5} kann nicht auf die angegebenen Typen angewendet werden.\nErforderlich: {2}\nErmittelt:    {3}\nGrund: {6}

# 0: symbol kind, 1: name, 2: list of type
compiler.err.cant.apply.symbols={0} f\u00FCr {1}({2}) nicht geeignet

# 0: symbol kind, 1: name, 2: list of type or message segment, 3: list of type or message segment, 4: symbol kind, 5: type, 6: message segment
compiler.misc.cant.apply.symbol={0} {1} in {4} {5} kann nicht auf die angegebenen Typen angewendet werden\nErforderlich: {2}\nErmittelt:    {3}\nGrund: {6}

# 0: symbol kind, 1: name, 2: list of type
compiler.misc.cant.apply.symbols={0} f\u00FCr {1}({2}) nicht geeignet

# 0: kind name, 1: symbol
compiler.misc.no.abstracts=Keine abstrakte Methode in {0} {1} gefunden

# 0: kind name, 1: symbol
compiler.misc.incompatible.abstracts=Mehrere nicht \u00FCberschreibende abstrakte Methoden in {0} {1} gefunden

compiler.err.bad.functional.intf.anno=Unerwartete @FunctionalInterface-Annotation

# 0: message segment
compiler.err.bad.functional.intf.anno.1=Unerwartete @FunctionalInterface-Annotation\n{0}

# 0: message segment
compiler.err.anonymous.diamond.method.does.not.override.superclass=Methode \u00FCberschreibt oder implementiert keine Methode aus einem Supertyp\n{0}

# 0: symbol
compiler.misc.not.a.functional.intf={0} ist keine Funktionsschnittstelle

# 0: symbol, 1: message segment
compiler.misc.not.a.functional.intf.1={0} ist keine Funktionsschnittstelle\n{1}

# 0: type, 1: kind name, 2: symbol
compiler.misc.invalid.generic.lambda.target=Ung\u00FCltiger Funktionsdeskriptor f\u00FCr Lambda-Ausdruck\nMethode {0} in {1} {2} ist generisch

# 0: kind name, 1: symbol
compiler.misc.incompatible.descs.in.functional.intf=Inkompatible Funktionsdeskriptoren in {0} {1} gefunden

# 0: name, 1: list of type, 2: type, 3: list of type
compiler.misc.descriptor=Deskriptor: {2} {0}({1})

# 0: name, 1: list of type, 2: type, 3: list of type
compiler.misc.descriptor.throws=Deskriptor: {2} {0}({1}) l\u00F6st {3} aus

# 0: type
compiler.misc.no.suitable.functional.intf.inst=Funktionsschnittstellendeskriptor f\u00FCr {0} kann nicht abgeleitet werden

# 0: message segment
compiler.misc.bad.intersection.target.for.functional.expr=Ung\u00FCltiges Schnittmengentypziel f\u00FCr Lambda oder Methodenreferenz\n{0}

# 0: symbol or type
compiler.misc.not.an.intf.component=Komponententyp {0} ist keine Schnittstelle

# 0: kind name, 1: message segment
compiler.err.invalid.mref=Ung\u00FCltige {0}-Referenz\n{1}

# 0: kind name, 1: message segment
compiler.misc.invalid.mref=Ung\u00FCltige {0}-Referenz\n{1}

compiler.misc.static.mref.with.targs=Parametrisierter Qualifier f\u00FCr statische Methodenreferenz

# 0: symbol
compiler.err.cant.assign.val.to.final.var=Der finalen Variable {0} kann kein Wert zugewiesen werden

compiler.err.cant.assign.val.to.this=Zuweisen zu "this" nicht m\u00F6glich

# 0: symbol, 1: message segment
compiler.err.cant.ref.non.effectively.final.var=Von {1} referenzierte lokale Variablen m\u00FCssen final oder effektiv final sein

compiler.err.try.with.resources.expr.needs.var=Die try-with-resources-Ressource muss eine Variablendeklaration oder ein Ausdruck mit einer Referenz zu einer finalen oder effektiv finalen Variable sein

# 0: symbol
compiler.err.try.with.resources.expr.effectively.final.var=Variable {0}, die als try-with-resources-Ressource verwendet wurde, ist weder final noch effektiv final


compiler.misc.lambda=Lambda-Ausdruck

compiler.misc.inner.cls=Innere Klasse

compiler.misc.guard=Guard

# 0: type
compiler.err.cant.deref={0} kann nicht dereferenziert werden

compiler.err.cant.extend.intf.annotation="extends" f\u00FCr @interfaces nicht zul\u00E4ssig

compiler.err.annotation.decl.not.allowed.here=Annotationsschnittstellendeklaration hier nicht zul\u00E4ssig

# 0: symbol
compiler.err.cant.inherit.from.final=Erben aus finalem {0}-Element nicht m\u00F6glich

# 0: symbol or string
compiler.err.cant.ref.before.ctor.called={0} kann nicht referenziert werden, bevor der Supertypkonstruktor aufgerufen wurde

compiler.err.cant.select.static.class.from.param.type=Statische Klasse kann nicht aus einem parametrisierten Typ ausgew\u00E4hlt werden

# 0: symbol, 1: string, 2: string
compiler.err.cant.inherit.diff.arg={0} kann nicht mit verschiedenen Argumenten geerbt werden: <{1}> und <{2}>

compiler.err.catch.without.try="catch" ohne "try"

# 0: kind name, 1: symbol
compiler.err.clash.with.pkg.of.same.name={0} {1} steht in Konflikt mit Package desselben Namens

compiler.err.class.not.allowed=Klassen-, Schnittstellen- oder Enum-Deklaration hier nicht zul\u00E4ssig

compiler.err.const.expr.req=Konstantenausdruck erforderlich

compiler.err.cont.outside.loop=Fortsetzung au\u00DFerhalb Schleife

# 0: symbol or type
compiler.err.cyclic.inheritance=Zyklische Vererbung mit {0}

# 0: symbol
compiler.err.cyclic.annotation.element=Typ von Element {0} ist zyklisch

# 0: symbol
compiler.err.call.to.super.not.allowed.in.enum.ctor=Aufruf von Super in Enum-Konstruktor nicht zul\u00E4ssig

# 0: type
compiler.err.no.superclass={0} weist keine Superklasse auf.

# 0: symbol, 1: type, 2: symbol, 3: type, 4: type
compiler.err.concrete.inheritance.conflict=Methoden {0} von {1} und {2} von {3} werden mit derselben Signatur geerbt

compiler.err.default.allowed.in.intf.annotation.member=Standardwert nur in einer Annotationsschnittstellendeklaration zul\u00E4ssig

# 0: symbol
compiler.err.doesnt.exist=Package {0} ist nicht vorhanden

# 0: type
compiler.err.duplicate.annotation.invalid.repeated=Annotation {0} ist keine g\u00FCltige wiederholbare Annotation

# 0: name, 1: type
compiler.err.duplicate.annotation.member.value=Doppeltes Element "{0}" in Annotation @{1}.

# 0: type
compiler.err.duplicate.annotation.missing.container={0} ist keine wiederholbare Annotationsschnittstelle

# 0: symbol
compiler.err.invalid.repeatable.annotation=Doppelte Annotation: {0} ist mit einer ung\u00FCltigen @Repeatable-Annotation versehen

# 0: symbol or type
compiler.err.invalid.repeatable.annotation.no.value={0} ist keine g\u00FCltige @Repeatable-Annotation. Keine Wertelementmethode deklariert

# 0: type, 1: number
compiler.err.invalid.repeatable.annotation.multiple.values={0} ist keine g\u00FCltige @Repeatable-Annotation. {1} Elementmethoden namens "value" deklariert

# 0: type
compiler.err.invalid.repeatable.annotation.invalid.value={0} ist keine g\u00FCltige @Repeatable-Annotation. Ung\u00FCltiges Wertelement

# 0: symbol or type, 1: type, 2: type
compiler.err.invalid.repeatable.annotation.value.return=\u00DCbergeordnete Annotationsschnittstelle ({0}) muss ein Element namens "value" mit dem Typ {2} deklarieren

# 0: symbol or type, 1: symbol
compiler.err.invalid.repeatable.annotation.elem.nondefault=\u00DCbergeordnete Annotationsschnittstelle ({0}) enth\u00E4lt keinen Standardwert f\u00FCr Element {1}

# 0: symbol, 1: string, 2: symbol, 3: string
compiler.err.invalid.repeatable.annotation.retention=Aufbewahrung der \u00FCbergeordneten Annotationsschnittstelle ({0}) ist k\u00FCrzer als die Aufbewahrung der wiederholbaren Annotationsschnittstelle ({2})

# 0: symbol, 1: symbol
compiler.err.invalid.repeatable.annotation.not.documented=Wiederholbare Annotationsschnittstelle ({1}) ist @Documented, die \u00FCbergeordnete Annotationsschnittstelle ({0}) aber nicht

# 0: symbol, 1: symbol
compiler.err.invalid.repeatable.annotation.not.inherited=Wiederholbare Annotationsschnittstelle ({1}) ist @Inherited, die \u00FCbergeordnete Annotationsschnittstelle ({0}) aber nicht

# 0: symbol, 1: symbol
compiler.err.invalid.repeatable.annotation.incompatible.target=\u00DCbergeordnete Annotationsschnittstelle ({0}) gilt f\u00FCr mehr Ziele als die wiederholbare Annotationsschnittstelle ({1})

# 0: symbol
compiler.err.invalid.repeatable.annotation.repeated.and.container.present=Container {0} darf nicht gleichzeitig mit dem darin enthaltenen Element vorhanden sein

# 0: type, 1: symbol
compiler.err.invalid.repeatable.annotation.not.applicable=Container {0} ist nicht anwendbar f\u00FCr Element {1}

# 0: type
compiler.err.invalid.repeatable.annotation.not.applicable.in.context=Container {0} ist in diesem Typkontext nicht anwendbar

# 0: name
compiler.err.duplicate.class=Doppelte Klasse: {0}

# 0: name, 1: name
compiler.err.same.binary.name=Klassen {0} und {1} haben denselben bin\u00E4ren Namen

compiler.err.duplicate.case.label=Doppeltes CASE-Label

compiler.err.pattern.dominated=Dieses CASE-Label wird von einem vorherigen CASE-Label dominiert

compiler.err.duplicate.default.label=Doppeltes Standardlabel

compiler.err.duplicate.total.pattern=Doppeltes Gesamtmuster

compiler.err.total.pattern.and.default=Switch umfasst sowohl Gesamtmuster als auch Standardlabel

# 0: type, 1: type
compiler.err.constant.label.not.compatible=Konstantes Label des Typs {0} ist nicht mit Switch-Selektortyp {1} kompatibel

compiler.err.flows.through.to.pattern=Ung\u00FCltiger Fallthrough zu einem Muster

compiler.err.flows.through.from.pattern=Ung\u00FCltiger Fallthrough von einem Muster

compiler.err.else.without.if="else" ohne "if"

compiler.err.empty.char.lit=Leeres Zeichenliteral

# 0: symbol
compiler.err.encl.class.required=Eine einschlie\u00DFende Instanz mit {0} ist erforderlich

compiler.err.enum.annotation.must.be.enum.constant=Ein Enum-Annotationswert muss eine Enum-Konstante sein

compiler.err.enum.cant.be.instantiated=Enum-Klassen d\u00FCrfen nicht instanziiert werden

compiler.err.enum.label.must.be.unqualified.enum=Das CASE-Label eines Enum-Switches muss der unqualifizierte Name einer Enumerationskonstante sein

compiler.err.enum.no.subclassing=Klassen k\u00F6nnen java.lang.Enum nicht direkt erweitern

compiler.err.enum.types.not.extensible=Enum-Klassen sind nicht erweiterbar

compiler.err.enum.no.finalize=Enums k\u00F6nnen keine Finalisierungsmethoden aufweisen

# 0: file name, 1: string
compiler.err.error.reading.file=Fehler beim Lesen von {0}. {1}

# 0: type
compiler.err.except.already.caught=Ausnahme {0} wurde bereits abgefangen

# 0: type
compiler.err.except.never.thrown.in.try=Ausnahme {0} wird nie im Body der entsprechenden try-Anweisung ausgel\u00F6st

# 0: symbol
compiler.err.final.parameter.may.not.be.assigned=final-Parameter {0} darf nicht zugewiesen werden

# 0: symbol
compiler.err.try.resource.may.not.be.assigned=auto-closeable-Ressource {0} darf nicht zugewiesen werden

# 0: symbol
compiler.err.multicatch.parameter.may.not.be.assigned=multi-catch-Parameter {0} darf nicht zugewiesen werden

# 0: type, 1: type
compiler.err.multicatch.types.must.be.disjoint=Alternativen in einer multi-catch-Anweisung d\u00FCrfen nicht durch Unterklassen verkn\u00FCpft sein\nAlternative {0} ist eine Unterklasse der Alternative {1}

compiler.err.finally.without.try="finally" ohne "try"

# 0: type, 1: message segment
compiler.err.foreach.not.applicable.to.type=for-each nicht auf Ausdruckstyp anwendbar\nErforderlich: {1}\nErmittelt:    {0}

compiler.err.fp.number.too.large=Gleitkommazahl zu gro\u00DF

compiler.err.fp.number.too.small=Gleitkommazahl zu klein

compiler.err.generic.array.creation=Erstellung von generischem Array

compiler.err.generic.throwable=Eine generische Klasse darf java.lang.Throwable nicht erweitern

# 0: symbol
compiler.err.icls.cant.have.static.decl=Unzul\u00E4ssige static-Deklaration in innerer Klasse {0}\nModifikator "static" ist nur in Konstantenvariablendeklarationen zul\u00E4ssig

# 0: string
compiler.err.illegal.char=Unzul\u00E4ssiges Zeichen: "{0}"

# 0: string, 1: string
compiler.err.illegal.char.for.encoding=Nicht zuordenbares Zeichen (0x{0}) f\u00FCr Codierung {1}

# 0: set of flag, 1: set of flag
compiler.err.illegal.combination.of.modifiers=Unzul\u00E4ssige Kombination aus Modifikatoren: {0} und {1}

compiler.err.illegal.enum.static.ref=Unzul\u00E4ssige Referenz zu statischem Feld aus Initializer

compiler.err.illegal.esc.char=Unzul\u00E4ssiges Escapezeichen

compiler.err.illegal.forward.ref=Unzul\u00E4ssige Vorw\u00E4rtsreferenz

# 0: symbol, 1: object
compiler.err.not.in.profile={0} ist in Profil "{1}" nicht verf\u00FCgbar

# 0: symbol
compiler.warn.forward.ref=Referenz zu Variable "{0}", bevor sie initialisiert wurde

compiler.err.illegal.self.ref=Selbstreferenz in Initializer

# 0: symbol
compiler.warn.self.ref=Selbstreferenz in Initializer von Variable "{0}"

# 0: type
compiler.err.illegal.initializer.for.type=Unzul\u00E4ssiger Initializer f\u00FCr {0}

compiler.err.illegal.line.end.in.char.lit=Unzul\u00E4ssiges Zeilenende in Zeichenliteral

compiler.err.illegal.text.block.open=Unzul\u00E4ssige Sequenz f\u00FCr \u00D6ffnungstrennzeichen von Textblock. Zeilenabschlusszeichen fehlt

compiler.warn.inconsistent.white.space.indentation=Inkonsistenter Leerzeicheneinzug

compiler.warn.trailing.white.space.will.be.removed=Nachgestelltes Leerzeichen wird entfernt

compiler.err.illegal.nonascii.digit=Unzul\u00E4ssige Nicht-ASCII-Ziffer

compiler.err.illegal.underscore=Unzul\u00E4ssiger Unterstrich

compiler.err.illegal.dot="." unzul\u00E4ssig

# 0: symbol
compiler.err.illegal.qual.not.icls=Unzul\u00E4ssiger Qualifier. {0} ist keine innere Klasse

compiler.err.illegal.start.of.expr=Unzul\u00E4ssiger Ausdrucksbeginn

compiler.err.illegal.start.of.stmt=Unzul\u00E4ssiger Anweisungsbeginn

compiler.err.illegal.start.of.type=Unzul\u00E4ssiger Typbeginn

compiler.err.illegal.parenthesized.expression=Unzul\u00E4ssiger Ausdruck in Klammern

compiler.err.illegal.unicode.esc=Unzul\u00E4ssiges Unicode-Escapezeichen

# 0: symbol
compiler.err.import.requires.canonical=Import erfordert kanonischen Namen f\u00FCr {0}

compiler.err.improperly.formed.type.param.missing=Falsch formatierter Typ. Einige Parameter fehlen

compiler.err.improperly.formed.type.inner.raw.param=Falsch formatierter Typ. Typargumente f\u00FCr Raw-Typ angegeben

# 0: type, 1: type
compiler.err.incomparable.types=Nicht vergleichbare Typen: {0} und {1}

# 0: string
compiler.err.int.number.too.large=Ganzzahl zu gro\u00DF

compiler.err.intf.annotation.members.cant.have.params=Elemente in Annotationsschnittstellendeklarationen k\u00F6nnen keine formalen Parameter deklarieren

# 0: symbol
compiler.err.intf.annotation.cant.have.type.params=Annotationsschnittstelle {0} darf nicht generisch sein

compiler.err.intf.annotation.members.cant.have.type.params=Elemente in Annotationsschnittstellendeklarationen k\u00F6nnen keine generischen Methoden sein

# 0: symbol, 1: type
compiler.err.intf.annotation.member.clash=Annotationsschnittstelle {1} deklariert ein Element mit demselben Namen wie Methode {0}

compiler.err.intf.expected.here=Hier wird eine Schnittstelle erwartet

compiler.err.intf.meth.cant.have.body=Abstrakte Schnittstellenmethoden k\u00F6nnen keinen Body enthalten

compiler.err.invalid.annotation.member.type=Ung\u00FCltiger Typ f\u00FCr Annotationsschnittstellenelement

compiler.err.invalid.binary.number=Bin\u00E4rzahlen m\u00FCssen mindestens eine Bin\u00E4rziffer enthalten

compiler.err.invalid.hex.number=Hexadezimalzahlen m\u00FCssen mindestens eine Hexadezimalziffer enthalten

compiler.err.invalid.meth.decl.ret.type.req=Ung\u00FCltige Methodendeklaration. R\u00FCckgabetyp erforderlich

compiler.err.varargs.and.old.array.syntax=Legacy-Arraynotation f\u00FCr Parameter mit variabler Argumentanzahl nicht zul\u00E4ssig

compiler.err.varargs.and.receiver =varargs-Notation f\u00FCr receiver-Parameter nicht zul\u00E4ssig

compiler.err.varargs.must.be.last =varargs-Parameter muss der letzte Parameter sein

compiler.err.array.and.receiver =Legacy-Arraynotation f\u00FCr receiver-Parameter nicht zul\u00E4ssig

compiler.err.wrong.receiver =Falscher receiver-Parametername

compiler.err.variable.not.allowed=Variablendeklaration hier nicht zul\u00E4ssig

# 0: name
compiler.err.label.already.in.use=Label {0} wird bereits verwendet

# 0: symbol
compiler.err.local.var.accessed.from.icls.needs.final=Auf lokale Variable {0} wird von innerer Klasse zugegriffen. Sie muss als final deklariert werden

compiler.err.local.enum=Enum-Klassen d\u00FCrfen nicht lokal sein

compiler.err.cannot.create.array.with.type.arguments=Array kann nicht mit Typargumenten erstellt werden

compiler.err.cannot.create.array.with.diamond=Array kann nicht mit "<>" erstellt werden

compiler.err.invalid.module.directive=Moduldirektiven-Schl\u00FCsselwort oder "}" erwartet

#
# limits.  We don't give the limits in the diagnostic because we expect
# them to change, yet we want to use the same diagnostic.  These are all
# detected during code generation.
#
compiler.err.limit.code=Code zu gro\u00DF

compiler.err.limit.code.too.large.for.try.stmt=Code f\u00FCr try-Anweisung zu gro\u00DF

compiler.err.limit.dimensions=Arraytyp hat zu viele Dimensionen

compiler.err.limit.locals=Zu viele lokale Variablen

compiler.err.limit.parameters=Zu viele Parameter

compiler.err.limit.pool=Zu viele Konstanten

compiler.err.limit.pool.in.class=Zu viele Konstanten in Klasse {0}

compiler.err.limit.stack=Code erfordert zu viel Stack

compiler.err.limit.string=Konstantenzeichenfolge zu lang

# 0: string
compiler.err.limit.string.overflow=UTF8-Darstellung f\u00FCr Zeichenfolge "{0}..." ist zu lang f\u00FCr den Konstantenpool

compiler.err.malformed.fp.lit=Nicht wohlgeformtes Gleitkommaliteral

compiler.err.method.does.not.override.superclass=Methode \u00FCberschreibt oder implementiert keine Methode aus einem Supertyp

compiler.err.static.methods.cannot.be.annotated.with.override=Statische Methoden k\u00F6nnen nicht mit @Override-Annotation versehen werden

compiler.err.missing.meth.body.or.decl.abstract=Methodenbody fehlt oder als abstrakt deklarieren

compiler.err.missing.ret.stmt=R\u00FCckgabeanweisung fehlt

# 0: type
compiler.misc.missing.ret.val=R\u00FCckgabewert fehlt

compiler.misc.unexpected.ret.val=Unerwarteter R\u00FCckgabewert

# 0: set of flag
compiler.err.mod.not.allowed.here=Modifikator {0} hier nicht zul\u00E4ssig

# 0: name
compiler.err.modifier.not.allowed.here=Modifikator {0} hier nicht zul\u00E4ssig

compiler.err.intf.not.allowed.here=Schnittstelle hier nicht zul\u00E4ssig

# 0: symbol, 1: symbol
compiler.err.name.clash.same.erasure=Namenskonflikt: {0} und {1} haben dieselbe Erasure

# 0: name, 1: list of type, 2: symbol, 3: name, 4: list of type, 5: symbol
compiler.err.name.clash.same.erasure.no.override=Namenskonflikt: {0}({1}) in {2} und {3}({4}) in {5} haben dieselbe Erasure, aber keine setzt die andere au\u00DFer Kraft

# 0: string, 1: name, 2: name, 3: list of type, 4: symbol, 5: name, 6: list of type, 7: symbol
compiler.err.name.clash.same.erasure.no.override.1=Namenskonflikt: {0} {1} hat zwei Methoden mit derselben Erasure, aber keine setzt die andere au\u00DFer Kraft\nErste Methode: {2}({3}) in {4}\nZweite Methode: {5}({6}) in {7}

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.err.name.clash.same.erasure.no.hide=Namenskonflikt: {0} in {1} und {2} in {3} haben dieselbe Erasure, aber keine blendet die andere aus

compiler.err.name.reserved.for.internal.use={0} ist f\u00FCr den internen Gebrauch reserviert

compiler.err.native.meth.cant.have.body=Native Methoden k\u00F6nnen keinen Body enthalten


# 0: message segment
compiler.misc.incompatible.type.in.conditional=Ung\u00FCltiger Typ in Bedingungsausdruck\n{0}

compiler.misc.conditional.target.cant.be.void=target-type f\u00FCr Bedingungsausdruck darf nicht "void" sein

compiler.misc.switch.expression.target.cant.be.void=target-type f\u00FCr Switch-Ausdruck darf nicht "void" sein

# 0: message segment
compiler.misc.incompatible.type.in.switch.expression=Ung\u00FCltiger Typ in Switch-Ausdruck\n{0}

# 0: message segment
compiler.misc.incompatible.ret.type.in.lambda=Ung\u00FCltiger R\u00FCckgabetyp in Lambda-Ausdruck\n{0}

compiler.misc.stat.expr.expected=Lambda-Body ist nicht mit einer void-Funktionsschnittstelle kompatibel\n(verwenden Sie stattdessen einen Block-Lambda-Body oder einen Anweisungsausdruck)

# 0: message segment
compiler.misc.incompatible.ret.type.in.mref=Ung\u00FCltiger R\u00FCckgabetyp in Methodenreferenz\n{0}

compiler.err.lambda.body.neither.value.nor.void.compatible=Lambda-Body ist weder mit Wert noch mit "void "kompatibel

# 0: list of type
compiler.err.incompatible.thrown.types.in.mref=Inkompatible ausgel\u00F6ste Typen {0} in Funktionsausdruck

compiler.misc.incompatible.arg.types.in.lambda=Inkompatible Parametertypen in Lambda-Ausdruck

compiler.misc.incompatible.arg.types.in.mref=Inkompatible Parametertypen in Methodenreferenz

compiler.err.new.not.allowed.in.annotation="new" in einer Annotation nicht zul\u00E4ssig

# 0: name, 1: type
compiler.err.no.annotation.member=Kein Annotationsmitglied {0} in {1}

# 0: symbol
compiler.err.no.encl.instance.of.type.in.scope=Keine einschlie\u00DFende Instanz vom Typ {0} im Geltungsbereich

compiler.err.no.intf.expected.here=Hier wird keine Schnittstelle erwartet

compiler.err.no.match.entry={0} hat keine \u00DCbereinstimmung im Eintrag in {1}. {2} erforderlich

# 0: type
compiler.err.not.annotation.type={0} ist keine Annotationsschnittstelle

# 0: symbol, 1: symbol, 2: message segment
compiler.err.not.def.access.package.cant.access={0} ist nicht sichtbar\n({2})

# 0: symbol, 1: symbol, 2: message segment
compiler.misc.not.def.access.package.cant.access={0} ist nicht sichtbar\n({2})

# 0: symbol, 1: message segment
compiler.err.package.not.visible=Package {0} ist nicht sichtbar\n({1})

# 0: symbol, 1: message segment
compiler.misc.package.not.visible=Package {0} ist nicht sichtbar\n({1})

# {0} - current module
# {1} - package in which the invisible class is declared
# {2} - module in which {1} is declared
# 0: symbol, 1: symbol, 2: symbol
compiler.misc.not.def.access.does.not.read=Package {1} wird in Modul {2} deklariert, aber nicht von Modul {0} gelesen

# {0} - package in which the invisible class is declared
# {1} - module in which {0} is declared
# 0: symbol, 1: symbol
compiler.misc.not.def.access.does.not.read.from.unnamed=Package {0} wird in Modul {1} deklariert, das nicht im Moduldiagramm enthalten ist

# {0} - package in which the invisible class is declared
# {1} - current module
# 0: symbol, 1: symbol
compiler.misc.not.def.access.does.not.read.unnamed=Package {0} wird im unbenannten Modul deklariert, aber nicht von Modul {1} gelesen

# {0} - package in which the invisible class is declared
# {1} - module in which {0} is declared
# 0: symbol, 1: symbol
compiler.misc.not.def.access.not.exported=Package {0} wird in Modul {1} deklariert, aber nicht exportiert

# {0} - package in which the invisible class is declared
# {1} - module in which {0} is declared
# 0: symbol, 1: symbol
compiler.misc.not.def.access.not.exported.from.unnamed=Package {0} wird in Modul {1} deklariert, aber nicht exportiert

# {0} - package in which the invisible class is declared
# {1} - module in which {0} is declared
# {2} - current module
# 0: symbol, 1: symbol, 2: symbol
compiler.misc.not.def.access.not.exported.to.module=Package {0} wird in Modul {1} deklariert, aber nicht in Modul {2} exportiert

# {0} - package in which the invisible class is declared
# {1} - module in which {0} is declared
# 0: symbol, 1: symbol
compiler.misc.not.def.access.not.exported.to.module.from.unnamed=Package {0} wird in Modul {1} deklariert, aber nicht in das unbenannte Modul exportiert

# 0: symbol, 1: symbol
compiler.err.not.def.access.class.intf.cant.access={1}.{0} ist in einer nicht zug\u00E4nglichen Klasse oder Schnittstelle definiert

# 0: symbol, 1: symbol
compiler.misc.not.def.access.class.intf.cant.access={1}.{0} ist in einer nicht zug\u00E4nglichen Klasse oder Schnittstelle definiert

# 0: symbol, 1: symbol, 2: symbol, 3: message segment
compiler.err.not.def.access.class.intf.cant.access.reason={1}.{0} in Package {2} ist nicht zug\u00E4nglich\n({3})

# 0: symbol, 1: symbol, 2: symbol, 3: message segment
compiler.misc.not.def.access.class.intf.cant.access.reason={1}.{0} in Package {2} ist nicht zug\u00E4nglich\n({3})

# 0: symbol, 1: list of type, 2: type
compiler.misc.cant.access.inner.cls.constr=Zugriff auf Konstruktor {0}({1}) nicht m\u00F6glich\nEinschlie\u00DFende Instanz vom Typ {2} ist nicht im Geltungsbereich

# 0: symbol, 1: symbol
compiler.err.not.def.public.cant.access={0} ist nicht \u00F6ffentlich in {1}. Zugriff von externem Package nicht m\u00F6glich

# 0: symbol, 1: symbol
compiler.err.not.def.public={0} ist nicht \u00F6ffentlich in {1}

# 0: symbol, 1: symbol
compiler.misc.not.def.public.cant.access={0} ist nicht \u00F6ffentlich in {1}. Zugriff von externem Package nicht m\u00F6glich

# 0: name
compiler.err.not.loop.label=Kein Schleifenlabel: {0}

compiler.err.not.stmt=Keine Anweisung

# 0: symbol
compiler.err.not.encl.class=Keine einschlie\u00DFende Klasse: {0}

# 0: name, 1: type
compiler.err.operator.cant.be.applied=Ung\u00FCltiger Operandentyp {1} f\u00FCr un\u00E4ren Operator "{0}"

# 0: name, 1: type, 2: type
compiler.err.operator.cant.be.applied.1=Ung\u00FCltige Operandentypen f\u00FCr un\u00E4ren Operator "{0}"\nErster Typ: {1}\nZweiter Typ: {2}

compiler.err.pkg.annotations.sb.in.package-info.java=Packageannotationen m\u00FCssen in der Datei package-info.java vorhanden sein

compiler.err.no.pkg.in.module-info.java=Packagedeklarationen in Datei module-info.java nicht zul\u00E4ssig

# 0: symbol
compiler.err.pkg.clashes.with.class.of.same.name=Es besteht ein Konflikt zwischen dem Package {0} und einer gleichnamigen Klasse

compiler.err.warnings.and.werror=Warnungen gefunden und -Werror angegeben

# Errors related to annotation processing

# 0: symbol, 1: message segment, 2: string (stack-trace)
compiler.err.proc.cant.access=Kein Zugriff auf {0}\n{1}\nDetails finden Sie im folgenden Stacktrace.\n{2}

# 0: symbol, 1: message segment
compiler.err.proc.cant.access.1=Kein Zugriff auf {0}\n{1}

# 0: string
compiler.err.proc.cant.find.class=Klassendatei f\u00FCr "{0}" konnte nicht gefunden werden.

# 0: string
compiler.err.proc.cant.load.class=Prozessorklassendatei konnte nicht geladen werden. Grund: "{0}".

# Print a client-generated error message; assumed to be localized, no translation required
# 0: string
compiler.err.proc.messager={0}

# 0: string
compiler.misc.exception.message={0}

compiler.misc.user.selected.completion.failure=Von Benutzer ausgew\u00E4hlter Abschlussfehler nach Klassenname

# 0: collection of string
compiler.err.proc.no.explicit.annotation.processing.requested=Klassennamen "{0}" werden nur akzeptiert, wenn die Annotationsverarbeitung explizit angefordert wird

compiler.err.proc.no.service=ServiceLoader konnte nicht verwendet werden und ist f\u00FCr Annotationsverarbeitung erforderlich.

# 0: string, 1: string
compiler.err.proc.processor.bad.option.name=Ung\u00FCltiger Optionsname "{0}" von Prozessor "{1}" angegeben

# 0: string
compiler.err.proc.processor.cant.instantiate=Instanz von Prozessor "{0}" konnte nicht instanziiert werden

# 0: string
compiler.err.proc.processor.not.found=Annotationsprozessor "{0}" nicht gefunden

# 0: string
compiler.err.proc.processor.wrong.type=Annotationsprozessor "{0}" implementiert nicht javax.annotation.processing.Processor

compiler.err.proc.service.problem=Fehler beim Erstellen eines Service-Loaders zum Laden von Prozessoren.

# 0: string
compiler.err.proc.bad.config.file=Ung\u00FCltige Servicekonfigurationsdatei, oder Ausnahme beim Erstellen des Prozessorobjekts ausgel\u00F6st: {0}

compiler.err.proc.cant.create.loader=Class Loader konnte nicht f\u00FCr Annotationsprozessoren erstellt werden: {0}

# 0: symbol
compiler.err.qualified.new.of.static.class="new" von statischer Klasse qualifiziert

compiler.err.recursive.ctor.invocation=Rekursiver Konstruktoraufruf

# 0: name, 1: symbol kind, 2: symbol, 3: symbol, 4: symbol kind, 5: symbol, 6: symbol
compiler.err.ref.ambiguous=Referenz zu {0} ist mehrdeutig\nSowohl {1} {2} in {3} als auch {4} {5} in {6} stimmen \u00FCberein

# 0: name, 1: symbol kind, 2: symbol, 3: symbol, 4: symbol kind, 5: symbol, 6: symbol
compiler.misc.ref.ambiguous=Referenz zu {0} ist mehrdeutig\nSowohl {1} {2} in {3} als auch {4} {5} in {6} stimmen \u00FCberein

compiler.err.repeated.annotation.target=Wiederholtes Annotationsziel

compiler.err.repeated.interface=Wiederholte Schnittstelle

compiler.err.repeated.modifier=Wiederholter Modifikator

# 0: symbol, 1: set of modifier, 2: symbol
compiler.err.report.access={0} hat {1}-Zugriff in {2}

# 0: symbol, 1: set of modifier, 2: symbol
compiler.misc.report.access={0} hat {1}-Zugriff in {2}

compiler.err.ret.outside.meth=R\u00FCckgabe au\u00DFerhalb von Methode

compiler.err.signature.doesnt.match.supertype=Signatur stimmt nicht mit {0} \u00FCberein. Inkompatibler Supertyp

compiler.err.signature.doesnt.match.intf=Signatur stimmt nicht mit {0} \u00FCberein. Inkompatible Schnittstellen

# 0: symbol, 1: symbol, 2: symbol
compiler.err.does.not.override.abstract={0} ist nicht abstrakt und setzt die abstrakte Methode {1} in {2} nicht au\u00DFer Kraft

# 0: file object
compiler.err.source.cant.overwrite.input.file=Fehler beim Schreiben von Quelle. Eingabedatei {0} kann nicht \u00FCberschrieben werden

# 0: symbol
compiler.err.stack.sim.error=Interner Fehler: Stacksimulationsfehler in {0}

compiler.err.static.imp.only.classes.and.interfaces=Statischer Import nur aus Klassen und Schnittstellen

compiler.err.string.const.req=Konstanten-Zeichenfolgenausdruck erforderlich

compiler.err.pattern.expected=Typmuster erwartet

# 0: symbol, 1: fragment
compiler.err.cannot.generate.class=Fehler beim Generieren der Klasse {0}\n({1})

# 0: symbol, 1: symbol
compiler.misc.synthetic.name.conflict=Das Symbol {0} steht mit einem vom Compiler synthetisierten Symbol in {1} in Konflikt

# 0: symbol, 1: type
compiler.misc.illegal.signature=Unzul\u00E4ssiges Signaturattribut f\u00FCr Typ {1}

compiler.err.throws.not.allowed.in.intf.annotation=Throws-Klausel in @interface-Mitgliedern nicht zul\u00E4ssig

compiler.err.try.without.catch.finally.or.resource.decls="try" ohne "catch", "finally" oder Ressourcendeklarationen

# 0: symbol
compiler.err.type.doesnt.take.params=Typ {0} akzeptiert keine Parameter

compiler.err.type.var.cant.be.deref=Auswahl aus Typvariable nicht m\u00F6glich

compiler.err.type.var.may.not.be.followed.by.other.bounds=Auf eine Typvariable d\u00FCrfen keine anderen Begrenzungen folgen

compiler.err.type.var.more.than.once=Typvariable {0} tritt mehrmals im Ergebnistyp von {1} auf. Sie muss instanziiert werden

compiler.err.type.var.more.than.once.in.result=Typvariable {0} tritt mehrmals im Typ von {1} auf. Sie muss instanziiert werden

# 0: type, 1: type, 2: fragment
compiler.err.types.incompatible=Die Typen {0} und {1} sind inkompatibel.\n{2}

# 0: name, 1: list of type
compiler.misc.incompatible.diff.ret=Beide definieren {0}({1}), aber mit nicht verwandten R\u00FCckgabetypen

# 0: kind name, 1: type, 2: name, 3: list of type, 4: symbol, 5: symbol
compiler.misc.incompatible.unrelated.defaults={0} {1} erbt nicht verwandte Standardwerte f\u00FCr {2}({3}) von Typen {4} und {5}

# 0: kind name, 1: type, 2: name, 3: list of type, 4: symbol, 5: symbol
compiler.misc.incompatible.abstract.default={0} {1} erbt abstrakte und Standardmethode f\u00FCr {2}({3}) von Typen {4} und {5}

# 0: name, 1: kind name, 2: symbol
compiler.err.default.overrides.object.member=Standardmethode {0} in {1} {2} setzt ein Mitglied von java.lang.Object au\u00DFer Kraft

# 0: type
compiler.err.illegal.static.intf.meth.call=Unzul\u00E4ssiger statischer Schnittstellenmethodenaufruf\nDer Empf\u00E4ngerausdruck muss durch den Typ-Qualifier "{0}" ersetzt werden

# 0: symbol or type, 1: message segment
compiler.err.illegal.default.super.call=Ung\u00FCltiger Typ-Qualifier {0} in Standardsuperaufruf\n{1}

# 0: symbol, 1: type
compiler.misc.overridden.default=Methode {0} wird in {1} au\u00DFer Kraft gesetzt

# 0: symbol, 1: type or symbol
compiler.misc.redundant.supertype=Redundante Schnittstelle {0} wird durch {1} erweitert

compiler.err.unclosed.char.lit=Nicht geschlossenes Zeichenliteral

compiler.err.unclosed.comment=Nicht geschlossener Kommentar

compiler.err.unclosed.str.lit=Nicht geschlossenes Zeichenfolgenliteral

compiler.err.unclosed.text.block=Nicht geschlossener Textblock

# 0: string
compiler.err.unsupported.encoding=Nicht unterst\u00FCtzte Codierung: {0}

compiler.err.io.exception=Fehler beim Lesen der Quelldatei: {0}

# 0: name
compiler.err.undef.label=Nicht definiertes Label: {0}

# 0: name
compiler.err.illegal.ref.to.restricted.type=Unzul\u00E4ssige Referenz zu eingeschr\u00E4nktem Typ "{0}"

# 0: name
compiler.warn.illegal.ref.to.restricted.type=Unzul\u00E4ssige Referenz zu eingeschr\u00E4nktem Typ "{0}"

# 0: name, 1: source
compiler.err.restricted.type.not.allowed="{0}" ist hier nicht zul\u00E4ssig\nAb Release {1} ist "{0}" ein eingeschr\u00E4nkter Typname, der nicht f\u00FCr Typdeklarationen verwendet werden kann

# 0: name, 1: source
compiler.warn.restricted.type.not.allowed=Ab Release {1} ist "{0}" ein eingeschr\u00E4nkter Typname, der nicht f\u00FCr Typdeklarationen oder als Elementtyp eines Arrays verwendet werden kann

# 0: name, 1: source
compiler.warn.restricted.type.not.allowed.preview="{0}" kann in einem zuk\u00FCnftigen Release ein eingeschr\u00E4nkter Typname werden, der nicht f\u00FCr Typdeklarationen oder als Elementtyp eines Arrays verwendet werden kann

# 0: name (variable), 1: message segment
compiler.err.cant.infer.local.var.type=Typ f\u00FCr lokale Variable {0} kann nicht abgeleitet werden\n({1})

# 0: name
compiler.err.restricted.type.not.allowed.here="{0}" ist hier nicht zul\u00E4ssig

# 0: name
compiler.err.restricted.type.not.allowed.array="{0}" ist nicht als Elementtyp eines Arrays zul\u00E4ssig

# 0: name
compiler.err.restricted.type.not.allowed.compound="{0}" ist nicht in einer zusammengesetzten Deklaration zul\u00E4ssig

# 0: fragment
compiler.err.invalid.lambda.parameter.declaration=Ung\u00FCltige Lambda-Parameterdeklaration\n({0})

compiler.misc.implicit.and.explicit.not.allowed=Implizit typisierte Parameter k\u00F6nnen nicht mit explizit typisierten Parametern gemischt werden

compiler.misc.var.and.explicit.not.allowed="var" kann nicht mit explizit typisierten Parametern gemischt werden

compiler.misc.var.and.implicit.not.allowed="var" kann nicht mit implizit typisierten Parametern gemischt werden

compiler.misc.local.cant.infer.null=Variablen-Initializer ist "null"

compiler.misc.local.cant.infer.void=Variablen-Initializer ist "void"

compiler.misc.local.missing.init="var" kann nicht f\u00FCr Variable ohne Initializer verwendet werden

compiler.misc.local.lambda.missing.target=Lambda-Ausdruck erfordert einen expliziten Zieltyp

compiler.misc.local.mref.missing.target=Methodenreferenz erfordert einen expliziten Zieltyp

compiler.misc.local.array.missing.target=Array-Initializer erfordert einen expliziten Zieltyp

compiler.misc.local.self.ref="var" kann nicht f\u00FCr selbstreferenzierende Variable verwendet werden

# 0: message segment, 1: unused
compiler.err.cant.apply.diamond=Typargumente f\u00FCr {0} k\u00F6nnen nicht abgeleitet werden

# 0: message segment or type, 1: message segment
compiler.err.cant.apply.diamond.1=Typargumente f\u00FCr {0} k\u00F6nnen nicht abgeleitet werden\nGrund: {1}

# 0: message segment or type, 1: message segment
compiler.misc.cant.apply.diamond.1=Typargumente f\u00FCr {0} k\u00F6nnen nicht abgeleitet werden\nGrund: {1}

compiler.err.unreachable.stmt=Nicht erreichbare Anweisung

compiler.err.not.exhaustive=Der Switch-Ausdruck deckt nicht alle m\u00F6glichen Eingabewerte ab

compiler.err.not.exhaustive.statement=Die Switch-Anweisung deckt nicht alle m\u00F6glichen Eingabewerte ab

compiler.err.initializer.must.be.able.to.complete.normally=Initializer muss normal abgeschlossen werden k\u00F6nnen

compiler.err.initializer.not.allowed=Initializer in Schnittstellen nicht zul\u00E4ssig

# 0: type
compiler.err.unreported.exception.need.to.catch.or.throw=Nicht gemeldete Ausnahme {0}. Muss abgefangen oder deklariert werden, um ausgel\u00F6st zu werden

# 0: type
compiler.err.unreported.exception.default.constructor=Nicht gemeldete Ausnahme {0} in Standardkonstruktor

# 0: type, 1: name
compiler.err.unreported.exception.implicit.close=Nicht gemeldete Ausnahme {0}. Muss abgefangen oder deklariert werden, um ausgel\u00F6st zu werden\nAusnahme bei implizitem Aufruf von close() f\u00FCr Ressourcenvariable "{1}" ausgel\u00F6st

compiler.err.void.not.allowed.here="void"-Typ hier nicht zul\u00E4ssig

# 0: string
compiler.err.wrong.number.type.args=Falsche Anzahl Typargumente. {0} erforderlich

# 0: symbol
compiler.err.var.might.already.be.assigned=Variable {0} wurde m\u00F6glicherweise bereits zugewiesen

# 0: symbol
compiler.err.var.might.not.have.been.initialized=Variable {0} wurde m\u00F6glicherweise nicht initialisiert

# 0: symbol
compiler.err.var.not.initialized.in.default.constructor=Variable {0} nicht im Standardkonstruktor initialisiert

# 0: symbol
compiler.err.var.might.be.assigned.in.loop=Variable {0} wurde m\u00F6glicherweise in Schleife zugewiesen

# 0: symbol, 1: message segment
compiler.err.varargs.invalid.trustme.anno=Ung\u00FCltige {0}-Annotation. {1}

# 0: type
compiler.misc.varargs.trustme.on.reifiable.varargs=Varargs-Elementtyp {0} ist reifizierbar.

# 0: type, 1: type
compiler.err.instanceof.reifiable.not.safe={0} kann nicht sicher in {1} konvertiert werden

# 0: type, 1: type
compiler.err.instanceof.pattern.no.subtype=Ausdruckstyp {0} ist ein Subtyp des Mustertyps {1}

# 0: symbol
compiler.misc.varargs.trustme.on.non.varargs.meth=Methode {0} ist keine varargs-Methode.

# 0: symbol
compiler.misc.varargs.trustme.on.non.varargs.accessor=Accessor {0} ist keine varargs-Methode.

# 0: symbol
compiler.misc.varargs.trustme.on.virtual.varargs=Instanzmethode {0} ist weder final noch privat.

# 0: symbol
compiler.misc.varargs.trustme.on.virtual.varargs.final.only=Instanzmethode {0} ist nicht final.

# 0: type, 1: symbol kind, 2: symbol
compiler.misc.inaccessible.varargs.type=Auf den formalen varargs-Elementtyp {0} kann nicht von {1} {2} zugegriffen werden

# In the following string, {1} will always be the detail message from
# java.io.IOException.
# 0: symbol, 1: string
compiler.err.class.cant.write=Fehler beim Schreiben von {0}: {1}

# In the following string, {0} is the name of the class in the Java source.
# It really should be used two times..
# 0: kind name, 1: name
compiler.err.class.public.should.be.in.file={0} {1} ist \u00F6ffentlich und muss in einer Datei namens {1}.java deklariert werden

## All errors which do not refer to a particular line in the source code are
## preceded by this string.
compiler.err.error=Fehler: 

# The following error messages do not refer to a line in the source code.
compiler.err.cant.read.file=Lesen nicht m\u00F6glich: {0}

# 0: string
compiler.err.plugin.not.found=Plug-in nicht gefunden: {0}

# 0: path
compiler.warn.locn.unknown.file.on.module.path=Unbekannte Datei in Modulpfad: {0}


# 0: path
compiler.err.locn.bad.module-info=Problem beim Lesen von module-info.class in {0}

# 0: path
compiler.err.locn.cant.read.directory=Verzeichnis {0} kann nicht gelesen werden

# 0: path
compiler.err.locn.cant.read.file=Datei {0} kann nicht gelesen werden

# 0: path
compiler.err.locn.cant.get.module.name.for.jar=Modulname f\u00FCr {0} kann nicht bestimmt werden

# 0: path
compiler.err.multi-module.outdir.cannot.be.exploded.module=Im Modus f\u00FCr mehrere Module kann das Ausgabeverzeichnis kein entpacktes Modul sein: {0}

# 0: path
compiler.warn.outdir.is.in.exploded.module=Das Ausgabeverzeichnis befindet sich in einem entpackten Modul: {0}

# 0: file object
compiler.err.locn.module-info.not.allowed.on.patch.path=module-info.class nicht in Patchpfad zul\u00E4ssig: {0}

# 0: string
compiler.err.locn.invalid.arg.for.xpatch=Ung\u00FCltiges Argument f\u00FCr --patch-module-Option: {0}

compiler.err.file.sb.on.source.or.patch.path.for.module=Datei muss sich im Quellpfad oder im Patchpfad f\u00FCr das Modul befinden

compiler.err.no.java.lang=Package java.lang kann in Plattformklassen nicht gefunden werden

#####

# Fatal Errors

# 0: name
compiler.misc.fatal.err.cant.locate.meth=Schwerwiegender Fehler: Methode {0} kann nicht gefunden werden

# 0: name
compiler.misc.fatal.err.cant.locate.field=Schwerwiegender Fehler: Feld {0} kann nicht gefunden werden

# 0: type
compiler.misc.fatal.err.cant.locate.ctor=Schwerwiegender Fehler: Konstruktor f\u00FCr {0} kann nicht gefunden werden

compiler.misc.fatal.err.cant.close=Schwerwiegender Fehler: Compiler-Ressourcen k\u00F6nnen nicht geschlossen werden

#####

##
## miscellaneous strings
##

compiler.misc.diamond.anonymous.methods.implicitly.override=(aufgrund von <> muss jede nicht private Methode, die in dieser anonymen Klasse deklariert ist, eine Methode aus einem Supertyp au\u00DFer Kraft setzen oder implementieren)

compiler.misc.source.unavailable=(Quelle nicht verf\u00FCgbar)

compiler.misc.base.membership=Alle Basisklassen geh\u00F6ren zu dieser Gruppe

# 0: string, 1: string, 2: boolean
compiler.misc.x.print.processor.info=Prozessor {0} entspricht {1} und gibt {2} zur\u00FCck.

# 0: number, 1: string, 2: set of symbol, 3: boolean
compiler.misc.x.print.rounds=Runde {0}:\n\tEingabedateien: {1}\n\tAnnotationen: {2}\n\tLetzte Runde: {3}

# 0: file name
compiler.warn.file.from.future=\u00C4nderungsdatum liegt in der Zukunft f\u00FCr Datei {0}

#####

## The following string will appear before all messages keyed as:
## "compiler.note".

compiler.note.compressed.diags=Einige Meldungen wurden vereinfacht. Wiederholen Sie die Kompilierung mit -Xdiags:verbose, um die vollst\u00E4ndige Ausgabe abzurufen

# 0: boolean, 1: symbol
compiler.note.lambda.stat=Lambda-Ausdruck wird \u00FCbersetzt\nAlternative Metafactory = {0}\nSynthetische Methode = {1}

# 0: boolean, 1: unused
compiler.note.mref.stat=Methodenreferenz wird \u00FCbersetzt\nAlternative Metafactory = {0}\n
# 0: boolean, 1: symbol
compiler.note.mref.stat.1=Methodenreferenz wird \u00FCbersetzt\nAlternative Metafactory = {0}\nBridgemethode = {1}

compiler.note.note=Hinweis: 

# 0: file name
compiler.note.deprecated.filename={0} verwendet oder \u00FCberschreibt eine veraltete API.

compiler.note.deprecated.plural=Einige Eingabedateien verwenden oder \u00FCberschreiben eine veraltete API.

# The following string may appear after one of the above deprecation
# messages.
compiler.note.deprecated.recompile=Wiederholen Sie die Kompilierung mit -Xlint:deprecation, um Details zu erhalten.

# 0: file name
compiler.note.deprecated.filename.additional={0} hat weitere Verwendungen oder Overrides einer veralteten API.

compiler.note.deprecated.plural.additional=Einige Eingabedateien verwenden oder \u00FCberschreiben zus\u00E4tzlich eine veraltete API.

# 0: file name
compiler.note.removal.filename={0} verwendet oder \u00FCberschreibt eine veraltete API, die zum Entfernen markiert ist.

compiler.note.removal.plural=Einige Eingabedateien verwenden oder \u00FCberschreiben eine veraltete API, die zum Entfernen markiert ist.

# The following string may appear after one of the above removal messages.
compiler.note.removal.recompile=Wiederholen Sie die Kompilierung mit -Xlint:removal, um Details zu erhalten.

# 0: file name
compiler.note.removal.filename.additional={0} hat weitere Verwendungen oder Overrides einer veralteten API, die zum Entfernen markiert ist.

compiler.note.removal.plural.additional=Einige Eingabedateien verwenden oder \u00FCberschreiben zus\u00E4tzlich eine veraltete API, die zum Entfernen markiert ist.

# 0: file name
compiler.note.unchecked.filename={0} verwendet nicht gepr\u00FCfte oder unsichere Vorg\u00E4nge.

compiler.note.unchecked.plural=Einige Eingabedateien verwenden nicht gepr\u00FCfte oder unsichere Vorg\u00E4nge.

# The following string may appear after one of the above unchecked messages.
compiler.note.unchecked.recompile=Wiederholen Sie die Kompilierung mit -Xlint:unchecked, um Details zu erhalten.

# 0: file name
compiler.note.unchecked.filename.additional={0} weist weitere nicht gepr\u00FCfte oder unsichere Vorg\u00E4nge auf.

compiler.note.unchecked.plural.additional=Einige Eingabedateien verwenden zus\u00E4tzlich nicht gepr\u00FCfte oder unsichere Vorg\u00E4nge.

# 0: file name, 1: source
compiler.note.preview.filename={0} verwendet Vorschaufeatures von Java SE {1}.

# 0: source
compiler.note.preview.plural=Einige Eingabedateien verwenden Vorschaufeatures von Java SE {0}.

# The following string may appear after one of the above deprecation
# messages.
compiler.note.preview.recompile=Wiederholen Sie die Kompilierung mit -Xlint:preview, um Details zu erhalten.

# 0: file name, 1: source
compiler.note.preview.filename.additional={0} hat weitere Verwendungen von Vorschaufeatures von Java SE {1}.

# 0: source
compiler.note.preview.plural.additional=Einige Eingabedateien verwenden zus\u00E4tzlich Vorschaufeatures von Java SE {0}.

# Notes related to annotation processing

# Print a client-generated note; assumed to be localized, no translation required
# 0: string
compiler.note.proc.messager={0}

# 0: string, 1: string, 2: string
compiler.note.multiple.elements=Mehrere Elemente namens "{1}" in Modulen "{2}" wurden von javax.lang.model.util.Elements.{0} gefunden.

#####

# 0: number
compiler.misc.count.error={0} Fehler

# 0: number
compiler.misc.count.error.plural={0} Fehler

# 0: number, 1: number
compiler.misc.count.error.recompile=Nur die ersten {0} Fehler von insgesamt {1} werden angezeigt. Mit -Xmaxerrs k\u00F6nnen Sie mehr Fehler anzeigen

# 0: number, 1: number
compiler.misc.count.warn.recompile=Nur die ersten {0} Warnungen von insgesamt {1} werden angezeigt. Mit -Xmaxwarns k\u00F6nnen Sie mehr Warnungen anzeigen

# 0: number
compiler.misc.count.warn={0} Warnung

# 0: number
compiler.misc.count.warn.plural={0} Warnungen

compiler.misc.version.not.available=(Versionsinformationen nicht verf\u00FCgbar)

## extra output when using -verbose (JavaCompiler)

# 0: symbol
compiler.misc.verbose.checking.attribution=[{0} wird gepr\u00FCft]

# 0: string
compiler.misc.verbose.parsing.done=[Parsen abgeschlossen: {0} ms]

# 0: file name
compiler.misc.verbose.parsing.started=[Parsen gestartet: {0}]

# 0: string
compiler.misc.verbose.total=[{0} ms gesamt]

# 0: file name
compiler.misc.verbose.wrote.file=[{0} geschrieben]

## extra output when using -verbose (code/ClassReader)
# 0: string
compiler.misc.verbose.loading=[{0} wird geladen]

# 0: string
compiler.misc.verbose.sourcepath=[Suchpfad f\u00FCr Quelldateien: {0}]

# 0: string
compiler.misc.verbose.classpath=[Suchpfad f\u00FCr Klassendateien: {0}]

## extra output when using -prompt (util/Log)
compiler.misc.resume.abort=F)ortsetzen, A)bbruch>

#####

##
## warnings
##

## All warning messages are preceded by the following string.
compiler.warn.warning=Warnung: 

## Warning messages may also include the following prefix to identify a
## lint option
# 0: option name
compiler.warn.lintOption=[{0}] 

# 0: symbol
compiler.warn.constant.SVUID=serialVersionUID muss Konstante in Klasse {0} sein

# 0: path
compiler.warn.dir.path.element.not.found=Ung\u00FCltiges Pfadelement "{0}": Verzeichnis nicht vorhanden

# 0: file name
compiler.warn.dir.path.element.not.directory=Ung\u00FCltiges Pfadelement "{0}": kein Verzeichnis

# 0: symbol, 1: symbol, 2: symbol
compiler.warn.missing-explicit-ctor=Klasse {0} in exportiertem Package {1} deklariert keine expliziten Konstruktoren und stellt daher einen Standardkonstruktor f\u00FCr Clients des Moduls {2} bereit

compiler.warn.strictfp=Ab Release 17 werden alle Gleitkommaausdr\u00FCcke streng ausgewertet. Daher ist "strictfp" nicht erforderlich

compiler.warn.finally.cannot.complete=Finally-Klausel kann nicht normal abgeschlossen werden

# 0: name
compiler.warn.poor.choice.for.module.name=Modulnamenskomponente {0} darf keine Ziffern am Ende enthalten

# 0: string
compiler.warn.incubating.modules=Inkubatormodul(e) verwendet: {0}

# 0: symbol, 1: symbol
compiler.warn.has.been.deprecated={0} in {1} ist veraltet

# 0: symbol, 1: symbol
compiler.warn.has.been.deprecated.for.removal={0} in {1} ist veraltet und wurde zum Entfernen markiert

# 0: symbol
compiler.warn.is.preview={0} ist eine Vorschau-API, die in einem zuk\u00FCnftigen Release entfernt werden kann.

# 0: symbol
compiler.err.is.preview={0} ist eine Vorschau-API, die standardm\u00E4\u00DFig deaktiviert ist.\n(Verwenden Sie --enable-preview, um Vorschau-APIs zu aktivieren)

# 0: symbol
compiler.warn.is.preview.reflective={0} ist eine reflektive Vorschau-API, die in einem zuk\u00FCnftigen Release entfernt werden kann.

# 0: symbol
compiler.warn.has.been.deprecated.module=Modul {0} ist veraltet

# 0: symbol
compiler.warn.has.been.deprecated.for.removal.module=Modul {0} ist veraltet und wurde zum Entfernen markiert

# 0: symbol
compiler.warn.sun.proprietary={0} ist eine interne propriet\u00E4re API, die in einem zuk\u00FCnftigen Release entfernt werden kann

compiler.warn.illegal.char.for.encoding=Nicht zuordenbares Zeichen f\u00FCr Codierung {0}

# 0: symbol
compiler.warn.improper.SVUID=serialVersionUID muss als "static final" in Klasse {0} deklariert sein

compiler.warn.improper.SPF=serialPersistentFields muss als "private static final" deklariert sein, um in Kraft zu treten

compiler.warn.SPF.null.init=serialPersistentFields tritt bei Initialisierung als Null nicht in Kraft.\nF\u00FChren Sie die Initialisierung zu einem leeren Array aus, um keine Felder anzugeben


# 0: type, 1: type
compiler.warn.inexact.non-varargs.call=Nicht-varargs-Aufruf von varargs-Methode mit ungenauem Argumenttyp f\u00FCr den letzten Parameter.\nF\u00FChren Sie f\u00FCr einen varargs-Aufruf eine Umwandlung mit Cast in {0} aus\nF\u00FChren Sie f\u00FCr einen Nicht-varargs-Aufruf eine Umwandlung mit Cast in {1} aus, um diese Warnung zu unterdr\u00FCcken

# 0: list of type
compiler.warn.unreachable.catch=Nicht erreichbare Catch-Klausel\nAusgel\u00F6ster Typ {0} wurde bereits abgefangen

# 0: list of type
compiler.warn.unreachable.catch.1=Nicht erreichbare Catch-Klausel\nAusgel\u00F6ste Typen {0} wurden bereits abgefangen

# 0: symbol
compiler.warn.long.SVUID=serialVersionUID muss den Typ "long" in Klasse {0} aufweisen

compiler.warn.OSF.array.SPF=serialPersistentFields muss den Typ "java.io.ObjectStreamField[]" aufweisen, um in Kraft zu treten

# 0: symbol
compiler.warn.missing.SVUID=Serialisierbare Klasse {0} enth\u00E4lt keine Definition von serialVersionUID

# 0: name
compiler.warn.serializable.missing.access.no.arg.ctor=Zugriff auf einen no-arg-Konstruktor in der ersten nicht serialisierbaren Superklasse {0} nicht m\u00F6glich

# 0: name
compiler.warn.serial.method.not.private=Serialisierungsbezogene Methode {0} nicht als privat deklariert

# 0: name
compiler.warn.serial.concrete.instance.method=Serialisierungsbezogene Methode {0} muss eine konkrete Instanzmethode sein, um in Kraft zu treten. Sie darf nicht abstrakt oder statisch sein

# 0: name
compiler.warn.serial.method.static=Serialisierungsbezogene Methode {0} ist als statisch deklariert. Sie muss stattdessen eine Instanzmethode sein, um in Kraft zu treten.

# 0: name
compiler.warn.serial.method.no.args=Serialisierungsbezogene Methode {0} darf keine Parameter aufweisen, um in Kraft zu treten

# 0: name, 1: number
compiler.warn.serial.method.one.arg=Serialisierungsbezogene Methode {0} muss genau einen Parameter aufweisen, um in Kraft zu treten. Sie darf nicht {1} Parameter enthalten

# 0: name, 1: type, 2: type
compiler.warn.serial.method.parameter.type=Der einzige Parameter der serialisierungsbezogenen Methode {0} muss den Typ {1} haben, um in Kraft zu treten. Er darf nicht den Typ {2} aufweisen

# 0: name, 1: type, 2: type
compiler.warn.serial.method.unexpected.return.type=Serialisierungsbezogene Methode {0} wurde mit dem R\u00FCckgabetyp {1} und nicht dem erwarteten Typ {2} deklariert.\nMit dieser Deklaration ist die Methode ung\u00FCltig f\u00FCr die Serialisierung

# 0: name, 1: type
compiler.warn.serial.method.unexpected.exception=Serialisierungsbezogene Methode {0} wurde zum Ausl\u00F6sen eines unerwarteten Typs {1} deklariert

compiler.warn.ineffectual.serial.field.interface=serialPersistentFields ist in einer Schnittstelle nicht effektiv

# 0: string
compiler.warn.ineffectual.serial.field.enum=Serialisierungsbezogenes Feld {0} ist in einer Enum-Klasse nicht effektiv

# 0: string
compiler.warn.ineffectual.serial.method.enum=Serialisierungsbezogene Methode {0} ist in einer Enum-Klasse nicht effektiv

compiler.warn.ineffectual.serial.field.record=serialPersistentFields ist in einer Datensatzklasse nicht effektiv

# 0: string
compiler.warn.ineffectual.serial.method.record=Serialisierungsbezogene Methode {0} ist in einer Datensatzklasse nicht effektiv

# 0: name
compiler.warn.ineffectual.serial.method.externalizable=Serialisierungsbezogene Methode {0} ist in einer externalisierbaren Klasse nicht effektiv

compiler.warn.ineffectual.serial.field.externalizable=serialPersistentFields ist in einer externalisierbaren Klasse nicht effektiv

compiler.warn.externalizable.missing.public.no.arg.ctor=Eine externalisierbare Klasse erfordert einen \u00F6ffentlichen no-arg-Konstruktor

compiler.warn.non.serializable.instance.field=Nicht transientes Instanzfeld einer serialisierbaren Klasse mit einem nicht serialisierbaren Typ deklariert

# 0: type
compiler.warn.non.serializable.instance.field.array=Nicht transientes Instanzfeld einer serialisierbaren Klasse wurde mit einem Array mit einem nicht serialisierbaren Basiskomponententyp {0} deklariert

compiler.warn.non.private.method.weaker.access=Serialisierungsbezogene Methode, die in einer Schnittstelle als nicht privat deklariert ist, verhindert,\ndass Klassen, die die Schnittstelle implementieren, die Methode als privat deklarieren

compiler.warn.default.ineffective=Serialisierungsbezogene Standardmethode aus einer Schnittstelle wird nicht von der Serialisierung f\u00FCr eine implementierende Klasse ausgef\u00FChrt

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.warn.potentially.ambiguous.overload={0} in {1} ist m\u00F6glicherweise mehrdeutig mit {2} in {3}

# 0: message segment
compiler.warn.override.varargs.missing={0}. Au\u00DFer Kraft gesetzte Methode umfasst kein "..."

# 0: message segment
compiler.warn.override.varargs.extra={0}. In au\u00DFer Kraft setzender Methode fehlt "..."

# 0: message segment
compiler.warn.override.bridge={0}. Au\u00DFer Kraft setzende Methode ist eine Bridgemethode

# 0: symbol
compiler.warn.pkg-info.already.seen=Die Datei package-info.java wurde bereits f\u00FCr Package {0} gefunden

# 0: path
compiler.warn.path.element.not.found=Ung\u00FCltiges Pfadelement "{0}": Datei oder Verzeichnis nicht vorhanden

compiler.warn.possible.fall-through.into.case=M\u00F6glicher Fallthrough in Case

# 0: type
compiler.warn.redundant.cast=Redundantes Casting in {0}

# 0: number
compiler.warn.position.overflow=Positionscodierungs\u00FCberlauf bei Zeile {0}

# 0: file name, 1: number, 2: number
compiler.warn.big.major.version={0}: Hauptversion {1} ist neuer als {2}, die h\u00F6chste Hauptversion, die von diesem Compiler unterst\u00FCtzt wird.\nEs wird empfohlen, dass Sie den Compiler upgraden.

# 0: kind name, 1: symbol
compiler.warn.static.not.qualified.by.type=Statische {0} muss mit Typname {1} anstelle eines Ausdrucks qualifiziert werden

# 0: string
compiler.warn.source.no.bootclasspath=Bootstrap Classpath nicht zusammen mit -source {0} festgelegt

# 0: string
compiler.warn.source.no.system.modules.path=Systemmodulpfad nicht zusammen mit -source {0} festgelegt

# 0: string
compiler.warn.option.obsolete.source=Quellwert {0} ist veraltet und wird in einem zuk\u00FCnftigen Release entfernt

# 0: target
compiler.warn.option.obsolete.target=Zielwert {0} ist veraltet und wird in einem zuk\u00FCnftigen Release entfernt

# 0: string, 1: string
compiler.err.option.removed.source=Quelloption {0} wird nicht mehr unterst\u00FCtzt. Verwenden Sie {1} oder h\u00F6her.

# 0: target, 1: target
compiler.err.option.removed.target=Zieloption {0} wird nicht mehr unterst\u00FCtzt. Verwenden Sie {1} oder h\u00F6her.


# 0: target, 1: target
compiler.warn.option.parameters.unsupported=-parameters wird f\u00FCr Zielwert {0} nicht unterst\u00FCtzt. Verwenden Sie {1} oder h\u00F6her.

compiler.warn.option.obsolete.suppression=Verwenden Sie -Xlint:-options, um Warnungen zu veralteten Optionen zu unterdr\u00FCcken.

# 0: name, 1: number, 2: number, 3: number, 4: number
compiler.warn.future.attr={0}-Attribut, das in Klassendateien der Version {1}.{2} eingef\u00FChrt wurde, wird in Klassendateien der Version {3}.{4} ignoriert

compiler.warn.requires.automatic=Erfordert Direktive f\u00FCr ein automatisches Modul

compiler.warn.requires.transitive.automatic=Erfordert transitive-Direktive f\u00FCr ein automatisches Modul

# Warnings related to annotation processing
# 0: string
compiler.warn.proc.package.does.not.exist=Package {0} ist nicht vorhanden

# 0: string
compiler.warn.proc.file.reopening=Versuch, mehrmals eine Datei f\u00FCr "{0}" zu erstellen

# 0: string
compiler.warn.proc.type.already.exists=Es ist bereits eine Datei f\u00FCr Typ "{0}" im Quellpfad oder Classpath vorhanden

# 0: string
compiler.warn.proc.type.recreate=Versuch, mehrmals eine Datei f\u00FCr Typ "{0}" zu erstellen

# 0: string
compiler.warn.proc.illegal.file.name=Datei kann nicht f\u00FCr unzul\u00E4ssigen Namen "{0}" erstellt werden.

# 0: string, 1: string
compiler.warn.proc.suspicious.class.name=Datei f\u00FCr einen Typ, dessen Name mit {1} endet, wird erstellt: "{0}"

# 0: string
compiler.warn.proc.file.create.last.round=Datei f\u00FCr Typ "{0}", die in der letzten Runde erstellt wurde, wird keiner Annotationsverarbeitung unterzogen.

# 0: string, 1: string
compiler.warn.proc.malformed.supported.string=Nicht wohlgeformte Zeichenfolge "{0}" f\u00FCr eine unterst\u00FCtzte Annotationsschnittstelle von Prozessor "{1}" zur\u00FCckgegeben

# 0: set of string
compiler.warn.proc.annotations.without.processors=Diese Annotationen wurden von keinem Prozessor beansprucht: {0}

# 0: source version, 1: string, 2: string
compiler.warn.proc.processor.incompatible.source.version=Unterst\u00FCtzte Quellversion "{0}" von Annotationsprozessor "{1}" kleiner als -source "{2}"

# 0: string, 1: string
compiler.warn.proc.duplicate.option.name=Doppelte unterst\u00FCtzte Option "{0}" von Annotationsprozessor "{1}" zur\u00FCckgegeben

# 0: string, 1: string
compiler.warn.proc.duplicate.supported.annotation=Doppelte unterst\u00FCtzte Annotationsschnittstelle "{0}" von Annotationsprozessor "{1}" zur\u00FCckgegeben

# 0: string
compiler.warn.proc.redundant.types.with.wildcard=Annotationsprozessor "{0}" unterst\u00FCtzt redundant sowohl "*" als auch andere Annotationsschnittstellen

compiler.warn.proc.proc-only.requested.no.procs=Annotationsverarbeitung ohne Kompilierung angefordert, aber keine Prozessoren gefunden.

compiler.warn.proc.use.implicit=Implizit kompilierte Dateien wurden keiner Annotationsverarbeitung unterzogen.\nVerwenden Sie -implicit, um eine Policy f\u00FCr die implizite Kompilierung anzugeben.

compiler.warn.proc.use.proc.or.implicit=Implizit kompilierte Dateien wurden keiner Annotationsverarbeitung unterzogen.\nVerwenden Sie -proc:none, um die Annotationsverarbeitung zu deaktivieren, oder -implicit, um eine Policy f\u00FCr die implizite Kompilierung anzugeben.

# Print a client-generated warning; assumed to be localized, no translation required
# 0: string
compiler.warn.proc.messager={0}

# 0: set of string
compiler.warn.proc.unclosed.type.files=Nicht geschlossene Dateien f\u00FCr die Typen "{0}". Diese Typen werden keiner Annotationsverarbeitung unterzogen

# 0: string
compiler.warn.proc.unmatched.processor.options=Die folgenden Optionen wurden von keinem Prozessor erkannt: "{0}"

compiler.warn.try.explicit.close.call=Expliziter Aufruf von close() f\u00FCr eine automatisch schlie\u00DFbare Ressource

# 0: symbol
compiler.warn.try.resource.not.referenced=Automatisch schlie\u00DFbare Ressource {0} wird nie im Body der entsprechenden try-Anweisung referenziert

# 0: type
compiler.warn.try.resource.throws.interrupted.exc=Automatisch schlie\u00DFbare Ressource {0} umfasst die Mitgliedsmethode close(), die InterruptedException ausl\u00F6sen k\u00F6nnte

compiler.warn.unchecked.assign=Nicht gepr\u00FCfte Zuweisung: {0} zu {1}

# 0: symbol, 1: type
compiler.warn.unchecked.assign.to.var=Nicht gepr\u00FCfte Zuweisung zu Variable {0} als Mitglied des Raw-Typs {1}

# 0: symbol, 1: type
compiler.warn.unchecked.call.mbr.of.raw.type=Nicht gepr\u00FCfter Aufruf von {0} als Mitglied des Raw-Typs {1}

compiler.warn.unchecked.cast.to.type=Nicht gepr\u00FCftes Casting zu Typ {0}

# 0: kind name, 1: name, 2: object, 3: object, 4: kind name, 5: symbol
compiler.warn.unchecked.meth.invocation.applied=Nicht gepr\u00FCfter Methodenaufruf: {0} {1} in {4} {5} wird auf die angegebenen Typen angewendet\nErforderlich: {2}\nErmittelt:    {3}

# 0: type
compiler.warn.unchecked.generic.array.creation=Nicht gepr\u00FCfte Erstellung eines generischen Arrays f\u00FCr varargs-Parameter des Typs {0}

# 0: type
compiler.warn.unchecked.varargs.non.reifiable.type=M\u00F6glich Heap-Besch\u00E4digung aus parametrisiertem vararg-Typ {0}

# 0: symbol
compiler.warn.varargs.unsafe.use.varargs.param=Varargs-Methode k\u00F6nnte Heap-Besch\u00E4digung aus nicht reifizierbarem varargs-Parameter {0} verursachen

compiler.warn.missing.deprecated.annotation=Veraltetes Element ist nicht mit @Deprecated-Annotation versehen

# 0: kind name
compiler.warn.deprecated.annotation.has.no.effect=@Deprecated-Annotation hat keine Auswirkung auf diese {0}-Deklaration

# 0: string
compiler.warn.invalid.path=Ung\u00FCltiger Dateiname: {0}

compiler.warn.doclint.not.available=Kein Serviceprovider f\u00FCr doclint verf\u00FCgbar

# 0: string
compiler.err.invalid.path=Ung\u00FCltiger Dateiname: {0}


# 0: path
compiler.warn.invalid.archive.file=Unerwartete Datei in Pfad: {0}

# 0: path
compiler.warn.unexpected.archive.file=Unerwartete Erweiterung f\u00FCr Archivdatei: {0}

# 0: path
compiler.err.no.zipfs.for.archive=Kein Dateisystemprovider zur Verarbeitung dieser Datei verf\u00FCgbar: {0}

compiler.warn.div.zero=Division durch Null

compiler.warn.empty.if=Leere Anweisung nach "if"

# 0: type, 1: name
compiler.warn.annotation.method.not.found=Annotationsmethode "{1}()" kann nicht in Typ "{0}" gefunden werden

# 0: type, 1: name, 2: message segment
compiler.warn.annotation.method.not.found.reason=Annotationsmethode "{1}()" kann nicht in Typ "{0}" gefunden werden: {2}

# 0: file object, 1: symbol, 2: name
compiler.warn.unknown.enum.constant=Unbekannte Enum-Konstante {1}.{2}

# 0: file object, 1: symbol, 2: name, 3: message segment
compiler.warn.unknown.enum.constant.reason=Unbekannte Enum-Konstante {1}.{2}\nGrund: {3}

# 0: type, 1: type
compiler.warn.raw.class.use=Raw-Typ gefunden: {0}\nTypargumente f\u00FCr generische Klasse {1} fehlen

compiler.warn.diamond.redundant.args=Redundante Typargumente in neuem Ausdruck (verwenden Sie stattdessen den Rautenoperator).

compiler.warn.local.redundant.type=Redundanter Typ f\u00FCr lokale Variable (ersetzen Sie den expliziten Typ durch "var").

compiler.warn.potential.lambda.found=Die Erstellung dieser anonymen inneren Klasse kann in einen Lambda-Ausdruck umgewandelt werden.

compiler.warn.method.redundant.typeargs=Redundante Typargumente in Methodenaufruf.

# 0: symbol, 1: message segment
compiler.warn.varargs.redundant.trustme.anno=Redundante {0}-Annotation. {1}

# 0: symbol
compiler.warn.access.to.member.from.serializable.element=Zugriff auf Mitglied {0} aus serialisierbarem Element kann \u00F6ffentlich f\u00FCr nicht vertrauensw\u00FCrdigen Code zug\u00E4nglich sein

# 0: symbol
compiler.warn.access.to.member.from.serializable.lambda=Zugriff auf Mitglied {0} aus serialisierbarem Lambda kann \u00F6ffentlich f\u00FCr nicht vertrauensw\u00FCrdigen Code zug\u00E4nglich sein

#####

## The following are tokens which are non-terminals in the language. They should
## be named as JLS3 calls them when translated to the appropriate language.
compiler.misc.token.identifier=<ID>

compiler.misc.token.character=<Zeichen>

compiler.misc.token.string=<Zeichenfolge>

compiler.misc.token.integer=<Ganzzahl>

compiler.misc.token.long-integer=<Ganzzahl vom Typ "long">

compiler.misc.token.float=<Float>

compiler.misc.token.double=<Double>

compiler.misc.token.bad-symbol=<ung\u00FCltiges Symbol>

compiler.misc.token.end-of-input=<Ende der Eingabe>

## The argument to the following string will always be one of the following:
## 1. one of the above non-terminals
## 2. a keyword (JLS1.8)
## 3. a boolean literal (JLS3.10.3)
## 4. the null literal (JLS3.10.7)
## 5. a Java separator (JLS3.11)
## 6. an operator (JLS3.12)
##
## This is the only place these tokens will be used.
# 0: token
compiler.err.expected={0} erwartet

# 0: string
compiler.err.expected.str={0} erwartet

# 0: token, 1: token
compiler.err.expected2={0} oder {1} erwartet

# 0: token, 1: token, 2: token
compiler.err.expected3={0}, {1} oder {2} erwartet

# 0: token, 1: token, 2: token, 3: string
compiler.err.expected4={0}, {1}, {2} oder {3} erwartet

compiler.err.premature.eof=Dateiende beim Parsen erreicht

compiler.err.enum.constant.expected=Hier wird eine Enum-Konstante erwartet

compiler.err.enum.constant.not.expected=Hier wird keine Enum-Konstante erwartet

## The following are related in form, but do not easily fit the above paradigm.
compiler.err.expected.module.or.open="module" oder "open" erwartet

compiler.err.dot.class.expected=".class" erwartet

## The argument to this string will always be either 'case' or 'default'.
# 0: token
compiler.err.orphaned={0} verwaist

# 0: name
compiler.misc.anonymous.class=<anonyme {0}>

# 0: name, 1: type
compiler.misc.type.captureof=capture#{0} von {1}

compiler.misc.type.captureof.1=capture#{0}

compiler.misc.type.none=<kein Wert>

compiler.misc.unnamed.package=Unbenanntes Package

compiler.misc.unnamed.module=Unbenanntes Modul

#####

# 0: symbol, 1: message segment
compiler.err.cant.access=Kein Zugriff auf {0}\n{1}

# 0: name
compiler.misc.bad.class.file=Klassendatei ist ung\u00FCltig f\u00FCr Klasse {0}

# 0: file name, 1: string (expected constant pool entry type), 2: number (constant pool index)
compiler.misc.bad.const.pool.entry=Ung\u00FCltiger Konstantenpooleintrag in {0}\n{1} bei Index {2} erwartet

# 0: file name, 1: number (constant pool index), 2: number (constant pool size)
compiler.misc.bad.const.pool.index=Ung\u00FCltiger Konstantenpoolindex in {0}\nIndex {1} liegt nicht innerhalb der Poolgr\u00F6\u00DFe {2}.

# 0: file name, 1: message segment
compiler.misc.bad.class.file.header=Ung\u00FCltige Klassendatei: {0}\n{1}\nEntfernen Sie die Datei, oder stellen Sie sicher, dass sie im richtigen Unterverzeichnis des Classpath vorhanden ist.

# 0: file name, 1: message segment
compiler.misc.bad.source.file.header=Ung\u00FCltige Quelldatei: {0}\n{1}\nEntfernen Sie die Datei, oder stellen Sie sicher, dass sie im richtigen Unterverzeichnis des Quellpfades vorhanden ist.

## The following are all possible strings for the second argument ({1}) of the
## above strings.
compiler.misc.bad.class.signature=Ung\u00FCltige Klassensignatur: {0}

#0: symbol, 1: symbol
compiler.misc.bad.enclosing.class=Ung\u00FCltige einschlie\u00DFende Klasse f\u00FCr {0}: {1}

# 0: symbol
compiler.misc.bad.enclosing.method=Ung\u00FCltiges einschlie\u00DFendes Methodenattribut f\u00FCr Klasse {0}

compiler.misc.bad.runtime.invisible.param.annotations=Ung\u00FCltiges RuntimeInvisibleParameterAnnotations-Attribut: {0}

compiler.misc.bad.const.pool.tag=Ung\u00FCltiges Konstantenpooltag: {0}

compiler.misc.bad.const.pool.tag.at=Ung\u00FCltiges Konstantenpooltag {0} bei {1}

compiler.misc.unexpected.const.pool.tag.at=Unerwartetes Konstantenpooltag {0} bei {1}

compiler.misc.bad.signature=Ung\u00FCltige Signatur: {0}

compiler.misc.bad.type.annotation.value=Ung\u00FCltiger Typ f\u00FCr Annotationszielwert: {0}

compiler.misc.bad.module-info.name=Ung\u00FCltiger Klassenname

compiler.misc.class.file.wrong.class=Klassendatei enth\u00E4lt falsche Klasse: {0}

compiler.misc.module.info.invalid.super.class=module-info mit ung\u00FCltiger Superklasse

# 0: name
compiler.misc.class.file.not.found=Klassendatei f\u00FCr {0} nicht gefunden

# 0: string (constant value), 1: symbol (constant field), 2: type (field type)
compiler.misc.bad.constant.range=Konstantenwert "{0}" f\u00FCr {1} liegt au\u00DFerhalb des erwarteten Bereichs f\u00FCr {2}

# 0: string (constant value), 1: symbol (constant field), 2: string (expected class)
compiler.misc.bad.constant.value=Ung\u00FCltiger Konstantenwert "{0}" f\u00FCr {1}. {2} erwartet

# 0: type (field type)
compiler.misc.bad.constant.value.type=Variable des Typs "{0}" darf keinen Konstantenwert aufweisen, aber es wurde einer f\u00FCr sie angegeben

# 0: string (classfile major version), 1: string (classfile minor version)
compiler.misc.invalid.default.interface=Standardmethode in Klassendatei der Version {0}.{1} gefunden

# 0: string (classfile major version), 1: string (classfile minor version)
compiler.misc.invalid.static.interface=Statische Methode in Klassendatei der Version {0}.{1} gefunden

# 0: string (classfile major version), 1: string (classfile minor version)
compiler.misc.anachronistic.module.info=Moduldeklaration in Klassendatei der Version {0}.{1} gefunden

compiler.misc.module.info.definition.expected=module-info-Definition erwartet

# 0: name
compiler.misc.file.doesnt.contain.class=Datei enth\u00E4lt nicht Klasse {0}

# 0: symbol
compiler.misc.file.does.not.contain.package=Datei enth\u00E4lt nicht Package {0}

compiler.misc.file.does.not.contain.module=Datei enth\u00E4lt keine Moduldeklaration

compiler.misc.illegal.start.of.class.file=Unzul\u00E4ssiger Klassendateibeginn

# 0: name
compiler.misc.method.descriptor.invalid=Methodendeskriptor ung\u00FCltig f\u00FCr {0}

compiler.misc.unable.to.access.file=Zugriff auf Datei nicht m\u00F6glich: {0}

compiler.misc.unicode.str.not.supported=Unicode-Zeichenfolge wird in Klassendatei nicht unterst\u00FCtzt

compiler.misc.undecl.type.var=Nicht deklarierte Typvariable: {0}

compiler.misc.malformed.vararg.method=Klassendatei enth\u00E4lt nicht wohlgeformte Methode mit variabler Argumentanzahl: {0}

compiler.misc.wrong.version=Klassendatei hat die falsche Version {0}.{1}. Sie muss {2}.{3} lauten

#####

# 0: type, 1: type or symbol
compiler.err.not.within.bounds=Typargument {0} liegt nicht innerhalb des g\u00FCltigen Bereichs von Typvariable {1}

## The following are all possible strings for the second argument ({1}) of the
## above string.

## none yet...

#####

# 0: message segment
compiler.err.prob.found.req=Inkompatible Typen: {0}

# 0: message segment
compiler.misc.prob.found.req=Inkompatible Typen: {0}

# 0: message segment, 1: type, 2: type
compiler.warn.prob.found.req={0}\nErforderlich: {2}\nErmittelt:    {1}

# 0: type, 1: type
compiler.misc.inconvertible.types={0} kann nicht in {1} konvertiert werden

# 0: type, 1: type
compiler.misc.possible.loss.of.precision=M\u00F6glicher Verlust bei Konvertierung von {0} in {1}

compiler.misc.unchecked.assign=Nicht gepr\u00FCfte Konvertierung

# compiler.misc.storecheck=\
#     assignment might cause later store checks to fail
# compiler.misc.unchecked=\
#     assigned array cannot dynamically check its stores
compiler.misc.unchecked.cast.to.type=Nicht gepr\u00FCftes Casting

# compiler.err.star.expected=\
#     ''*'' expected
# compiler.err.no.elem.type=\
#     \[\*\] cannot have a type

# 0: message segment
compiler.misc.try.not.applicable.to.type=try-with-resources nicht auf Variablentyp anwendbar\n({0})

#####

# 0: object, 1: message segment
compiler.err.type.found.req=Unerwarteter Typ\nErforderlich: {1}\nErmittelt:    {0}

## The following are all possible strings for the first argument ({0}) of the
## above string.
compiler.misc.type.req.class=Klasse

compiler.misc.type.req.class.array=Klasse oder Array

compiler.misc.type.req.array.or.iterable=Array oder java.lang.Iterable

compiler.misc.type.req.ref=Referenz

compiler.misc.type.req.exact=Klasse oder Schnittstelle ohne Grenzwerte

# 0: type
compiler.misc.type.parameter=Typparameter {0}

#####

## The following are all possible strings for the last argument of all those
## diagnostics whose key ends in ".1"

# 0: type, 1: list of type
compiler.misc.no.unique.maximal.instance.exists=Keine eindeutige maximale Instanz f\u00FCr Typvariable {0} mit oberen Grenzwerten {1} vorhanden

# 0: type, 1: list of type
compiler.misc.no.unique.minimal.instance.exists=Keine eindeutige minimale Instanz f\u00FCr Typvariable {0} mit unteren Grenzwerten {1} vorhanden

# 0: type, 1: list of type
compiler.misc.incompatible.upper.bounds=Inferenzvariable {0} hat inkompatible obere Grenzwerte {1}

# 0: type, 1: list of type
compiler.misc.incompatible.eq.bounds=Inferenzvariable {0} hat inkompatible Gleichheits-Constraints {1}

# 0: type, 1: fragment, 2: fragment
compiler.misc.incompatible.bounds=Inferenzvariable {0} hat inkompatible Grenzwerte\n{1}\n{2}

# 0: list of type
compiler.misc.lower.bounds=Untere Grenzwerte: {0}

# 0: list of type
compiler.misc.eq.bounds=Gleichheits-Constraints: {0}

# 0: list of type
compiler.misc.upper.bounds=Untere Grenzwerte: {0}

# 0: list of type, 1: type, 2: type
compiler.misc.infer.no.conforming.instance.exists=Keine Instanzen von Typvariablen {0} vorhanden, sodass {1} {2} entspricht

# 0: list of type, 1: message segment
compiler.misc.infer.no.conforming.assignment.exists=Typvariable(n) {0} nicht ableitbar\n(nicht \u00FCbereinstimmende Argumente; {1})

# 0: list of type
compiler.misc.infer.arg.length.mismatch=Typvariable(n) {0} nicht ableitbar\n(Liste der tats\u00E4chlichen Argumente hat eine andere L\u00E4nge als die der formalen Argumente)

# 0: list of type, 1: message segment
compiler.misc.infer.varargs.argument.mismatch=Typvariable(n) {0} nicht ableitbar\n(nicht \u00FCbereinstimmende varargs, {1})

# 0: type, 1: list of type
compiler.misc.inferred.do.not.conform.to.upper.bounds=Abgeleiteter Typ entspricht nicht den oberen Grenzwerten\nAbgeleitet: {0}\nObere Grenzwerte: {1}

# 0: type, 1: list of type
compiler.misc.inferred.do.not.conform.to.lower.bounds=Abgeleiteter Typ entspricht nicht den unteren Grenzwerten\nAbgeleitet: {0}\nUntere Grenzwerte: {1}

# 0: type, 1: list of type
compiler.misc.inferred.do.not.conform.to.eq.bounds=Abgeleiteter Typ entspricht nicht den Gleichheits-Constraints\nAbgeleitet: {0}\nGleichheits-Constraint(s): {1}

# 0: symbol
compiler.misc.diamond={0}<>

# 0: type
compiler.misc.diamond.non.generic="<>" kann nicht mit der nicht generischen Klasse {0} verwendet werden

# 0: list of type, 1: message segment
compiler.misc.diamond.invalid.arg=Typargument {0}, das f\u00FCr {1} abgeleitet wurde, ist in diesem Kontext nicht zul\u00E4ssig\nDas abgeleitete Argument kann nicht im Signaturattribut ausgedr\u00FCckt werden

# 0: list of type, 1: message segment
compiler.misc.diamond.invalid.args=Typargumente {0}, die f\u00FCr {1} abgeleitet wurden, sind in diesem Kontext nicht zul\u00E4ssig\nAbgeleitete Argumente k\u00F6nnen nicht im Signaturattribut ausgedr\u00FCckt werden

# 0: type
compiler.misc.diamond.and.explicit.params="<>" kann nicht mit expliziten Typparametern f\u00FCr Konstruktor verwendet werden

compiler.misc.mref.infer.and.explicit.params=Raw-Konstruktorreferenz kann nicht mit expliziten Typparametern f\u00FCr Konstruktor verwendet werden

# 0: type, 1: list of type
compiler.misc.explicit.param.do.not.conform.to.bounds=Explizites Typargument {0} entspricht nicht den deklarierten Grenzwerten {1}

compiler.misc.arg.length.mismatch=Liste der tats\u00E4chlichen Argumente hat eine andere L\u00E4nge als die der formalen Argumente

# 0: string
compiler.misc.wrong.number.type.args=Falsche Anzahl Typargumente. {0} erforderlich

# 0: message segment
compiler.misc.no.conforming.assignment.exists=Keine \u00FCbereinstimmenden Argumente, {0}

# 0: message segment
compiler.misc.varargs.argument.mismatch=Keine \u00FCbereinstimmenden varargs; {0}

#####

# 0: symbol or type, 1: file name
compiler.warn.auxiliary.class.accessed.from.outside.of.its.source.file=Auf Auxiliary-Klasse {0} in {1} darf nicht von au\u00DFerhalb der eigenen Quelldatei zugegriffen werden

## The first argument ({0}) is a "kindname".
# 0: kind name, 1: symbol, 2: symbol
compiler.err.abstract.cant.be.accessed.directly={0} {1} in {2} ist abstrakt und kann nicht direkt aufgerufen werden

## The first argument ({0}) is a "kindname".
# 0: symbol kind, 1: symbol
compiler.err.non-static.cant.be.ref={0} {1} ist nicht statisch und kann nicht aus einem statischen Kontext referenziert werden

# 0: symbol kind, 1: symbol
compiler.misc.bad.static.method.in.unbound.lookup=Unerwartete statische {0} {1} in ungebundenem Lookup gefunden

# 0: symbol kind, 1: symbol
compiler.misc.bad.instance.method.in.unbound.lookup=Unerwartete Instanz {0} {1} in ungebundenem Lookup gefunden

# 0: symbol kind, 1: symbol
compiler.misc.bad.static.method.in.bound.lookup=Unerwartete statische {0} {1} in gebundenem Lookup gefunden

## Both arguments ({0}, {1}) are "kindname"s.  {0} is a comma-separated list
## of kindnames (the list should be identical to that provided in source.
# 0: set of kind name, 1: set of kind name
compiler.err.unexpected.type=Unerwarteter Typ\nErforderlich: {0}\nErmittelt:    {1}

compiler.err.unexpected.lambda=Hier wird kein Lambda-Ausdruck erwartet

compiler.err.unexpected.mref=Hier wird keine Methodenreferenz erwartet

## The first argument {0} is a "kindname" (e.g. 'constructor', 'field', etc.)
## The second argument {1} is the non-resolved symbol
## The third argument {2} is a list of type parameters (non-empty if {1} is a method)
## The fourth argument {3} is a list of argument types (non-empty if {1} is a method)
# 0: kind name, 1: name, 2: unused, 3: unused
compiler.err.cant.resolve=Symbol nicht gefunden\nSymbol: {0} {1}

# 0: kind name, 1: name, 2: unused, 3: list of type
compiler.err.cant.resolve.args=Symbol nicht gefunden\nSymbol: {0} {1}({3})

# 0: kind name, 1: name, 2: unused, 3: list of type
compiler.misc.cant.resolve.args=Symbol nicht gefunden\nSymbol: {0} {1}({3})

# 0: kind name, 1: name, 2: list of type, 3: list of type
compiler.err.cant.resolve.args.params=Symbol nicht gefunden\nSymbol: {0} <{2}>{1}({3})

## arguments from {0} to {3} have the same meaning as above
## The fifth argument {4} is a location subdiagnostic (see below)
# 0: kind name, 1: name, 2: unused, 3: unused, 4: message segment
compiler.err.cant.resolve.location=Symbol nicht gefunden\nSymbol: {0} {1}\nOrt: {4}

# 0: kind name, 1: name, 2: unused, 3: list of type, 4: message segment
compiler.err.cant.resolve.location.args=Symbol nicht gefunden\nSymbol: {0} {1}({3})\nOrt: {4}

# 0: kind name, 1: name, 2: list of type, 3: list, 4: message segment
compiler.err.cant.resolve.location.args.params=Symbol nicht gefunden\nSymbol: {0} <{2}>{1}({3})\nOrt: {4}

### Following are replicated/used for method reference diagnostics

# 0: kind name, 1: name, 2: unused, 3: list of type, 4: message segment
compiler.misc.cant.resolve.location.args=Symbol nicht gefunden\nSymbol: {0} {1}({3})\nOrt: {4}

# 0: kind name, 1: name, 2: list of type, 3: list, 4: message segment
compiler.misc.cant.resolve.location.args.params=Symbol nicht gefunden\nSymbol: {0} <{2}>{1}({3})\nOrt: {4}

##a location subdiagnostic is composed as follows:
## The first argument {0} is the location "kindname" (e.g. 'constructor', 'field', etc.)
## The second argument {1} is the location name
## The third argument {2} is the location type (only when {1} is a variable name)

# 0: kind name, 1: type or symbol, 2: unused
compiler.misc.location={0} {1}

# 0: kind name, 1: symbol, 2: type
compiler.misc.location.1={0} {1} von Typ {2}

## The following are all possible string for "kindname".
## They should be called whatever the JLS calls them after it been translated
## to the appropriate language.
# compiler.misc.kindname.constructor=\
#     static member
compiler.misc.kindname.annotation=@interface

compiler.misc.kindname.constructor=Konstruktor

compiler.misc.kindname.enum=Enumeration

compiler.misc.kindname.interface=Schnittstelle

compiler.misc.kindname.static=statisch

compiler.misc.kindname.type.variable=Typvariable

compiler.misc.kindname.type.variable.bound=Grenzwert von Typvariable

compiler.misc.kindname.variable=Variable

compiler.misc.kindname.value=Wert

compiler.misc.kindname.method=Methode

compiler.misc.kindname.class=Klasse

compiler.misc.kindname.package=Package

compiler.misc.kindname.module=Modul

compiler.misc.kindname.static.init=statischer Initializer

compiler.misc.kindname.instance.init=Instanz-Initializer

compiler.misc.kindname.record.component=Datensatzkomponente

compiler.misc.kindname.record=Datensatz

#####

compiler.misc.no.args=keine Argumente

# 0: message segment
compiler.err.override.static={0}\nAu\u00DFer Kraft setzende Methode ist statisch

# 0: message segment, 1: set of flag
compiler.err.override.meth={0}\nAu\u00DFer Kraft gesetzte Methode ist {1}

# 0: message segment, 1: type
compiler.err.override.meth.doesnt.throw={0}\nAu\u00DFer Kraft gesetzte Methode l\u00F6st nicht {1} aus

# In the following string {1} is a space separated list of Java Keywords, as
# they would have been declared in the source code
# 0: message segment, 1: set of flag or string
compiler.err.override.weaker.access={0}\nVersuch, niedrigere Zugriffsberechtigungen zuzuweisen. War {1}

# 0: message segment, 1: type, 2: type
compiler.err.override.incompatible.ret={0}\nR\u00FCckgabetyp {1} ist nicht mit {2} kompatibel

# 0: message segment, 1: type, 2: type
compiler.warn.override.unchecked.ret={0}\nR\u00FCckgabetyp erfordert eine nicht gepr\u00FCfte Konvertierung von {1} in {2}

# 0: message segment, 1: type
compiler.warn.override.unchecked.thrown={0}\nAu\u00DFer Kraft gesetzte Methode l\u00F6st nicht {1} aus

# 0: symbol
compiler.warn.override.equals.but.not.hashcode=Klasse {0} setzt Gleichwertige au\u00DFer Kraft. hashCode-Methode wird aber weder von der Klasse noch einer Superklasse au\u00DFer Kraft gesetzt

## The following are all possible strings for the first argument ({0}) of the
## above strings.
# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.misc.cant.override={0} in {1} kann nicht {2} in {3} au\u00DFer Kraft setzen

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.misc.cant.hide={0} in {1} kann nicht {2} in {3} ausblenden

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.misc.cant.implement={0} in {1} kann nicht {2} in {3} implementieren

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.misc.clashes.with={0} in {1} steht mit {2} in {3} in Konflikt

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.misc.unchecked.override={0} in {1} setzt {2} in {3} au\u00DFer Kraft

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.misc.unchecked.implement={0} in {1} implementiert {2} in {3}

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.misc.unchecked.clash.with={0} in {1} setzt {2} in {3} au\u00DFer Kraft

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.misc.varargs.override={0} in {1} setzt {2} in {3} au\u00DFer Kraft

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.misc.varargs.implement={0} in {1} implementiert {2} in {3}

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.misc.varargs.clash.with={0} in {1} setzt {2} in {3} au\u00DFer Kraft

# 0: kind name, 1: symbol, 2: symbol, 3: message segment
compiler.misc.inapplicable.method={0} {1}.{2} ist nicht anwendbar\n({3})

########################################
# Diagnostics for language feature changes.
# Such diagnostics have a common template which can be customized by using a feature
# diagnostic fragment (one of those given below).
########################################

# 0: message segment (feature), 1: string (found version), 2: string (expected version)
compiler.err.feature.not.supported.in.source={0} wird in -source {1} nicht unterst\u00FCtzt\n(Verwenden Sie -source {2} oder h\u00F6her, um {0} zu aktivieren)

# 0: message segment (feature), 1: string (found version), 2: string (expected version)
compiler.err.feature.not.supported.in.source.plural={0} werden in -source {1} nicht unterst\u00FCtzt\n(Verwenden Sie -source {2} oder h\u00F6her, um {0} zu aktivieren)

# 0: message segment (feature), 1: string (found version), 2: string (expected version)
compiler.misc.feature.not.supported.in.source={0} wird in -source {1} nicht unterst\u00FCtzt\n(Verwenden Sie -source {2} oder h\u00F6her, um {0} zu aktivieren)

# 0: message segment (feature), 1: string (found version), 2: string (expected version)
compiler.misc.feature.not.supported.in.source.plural={0} werden in -source {1} nicht unterst\u00FCtzt\n(Verwenden Sie -source {2} oder h\u00F6her, um {0} zu aktivieren)

# 0: message segment (feature)
compiler.err.preview.feature.disabled={0} ist ein Vorschaufeature, das standardm\u00E4\u00DFig deaktiviert ist.\n(Verwenden Sie --enable-preview, um {0} zu aktivieren)

# 0: message segment (feature)
compiler.err.preview.feature.disabled.plural={0} sind ein Vorschaufeature, das standardm\u00E4\u00DFig deaktiviert ist.\n(Verwenden Sie --enable-preview, um {0} zu aktivieren)

# 0: file object (classfile), 1: string (expected version)
compiler.err.preview.feature.disabled.classfile=Klassendatei f\u00FCr {0} verwendet Vorschaufeatures von Java SE {1}.\n(Verwenden Sie --enable-preview, um das Laden von Klassendateien mit Vorschaufeatures zu erm\u00F6glichen)

# 0: message segment (feature)
compiler.warn.preview.feature.use={0} ist ein Vorschaufeature, das in einem zuk\u00FCnftigen Release entfernt werden kann.

# 0: message segment (feature)
compiler.warn.preview.feature.use.plural={0} sind ein Vorschaufeature, das in einem zuk\u00FCnftigen Release entfernt werden kann.

# 0: file object (classfile), 1: string (expected version)
compiler.warn.preview.feature.use.classfile=Klassendatei f\u00FCr {0} verwendet Vorschaufeatures von Java SE {1}.


compiler.misc.feature.modules=Module

compiler.misc.feature.diamond.and.anon.class="<>" mit anonymen inneren Klassen

compiler.misc.feature.var.in.try.with.resources=Variablen in try-with-resources

compiler.misc.feature.type.annotations=Typannotationen

compiler.misc.feature.annotations.after.type.params=Annotationen nach Methodentypparametern

compiler.misc.feature.repeatable.annotations=Wiederholte Annotationen

compiler.misc.feature.diamond=Rautenoperator

compiler.misc.feature.lambda=Lambda-Ausdr\u00FCcke

compiler.misc.feature.method.references=Methodenreferenzen

compiler.misc.feature.default.methods=Standardmethoden

compiler.misc.feature.intersection.types.in.cast=Schnittmengentypen

compiler.misc.feature.static.intf.methods=Statische Schnittstellenmethoden

compiler.misc.feature.static.intf.method.invoke=Aufrufe statischer Schnittstellenmethoden

compiler.misc.feature.private.intf.methods=Private Schnittstellenmethoden

compiler.misc.feature.text.blocks=Textbl\u00F6cke

compiler.misc.feature.multiple.case.labels=Mehrere CASE-Labels

compiler.misc.feature.switch.rules=Switch-Regeln

compiler.misc.feature.switch.expressions=Switch-Ausdr\u00FCcke

compiler.misc.feature.var.syntax.in.implicit.lambda=var-Syntax in impliziten Lambdas

compiler.misc.feature.pattern.matching.instanceof=Musterabgleich in instanceof

compiler.misc.feature.reifiable.types.instanceof=Reifizierbare Typen in instanceof

compiler.misc.feature.records=Datens\u00E4tze

compiler.misc.feature.sealed.classes=Verschl\u00FCsselte Klassen

compiler.misc.feature.case.null=Null in Switch Cases

compiler.misc.feature.pattern.switch=Muster in Switch-Anweisungen

compiler.warn.underscore.as.identifier=Ab Release 9 ist "_" ein Schl\u00FCsselwort und kann nicht als ID verwendet werden

compiler.err.underscore.as.identifier=Ab Release 9 ist "_" ein Schl\u00FCsselwort und kann nicht als ID verwendet werden

compiler.err.underscore.as.identifier.in.lambda="_" als ID verwendet\n("_" darf nicht als ID f\u00FCr Lambda-Parameter verwendet werden)

compiler.err.enum.as.identifier=Ab Release 5 ist "enum" ein Schl\u00FCsselwort und kann nicht als ID verwendet werden

compiler.err.assert.as.identifier=Ab Release 1.4 ist "assert" ein Schl\u00FCsselwort und kann nicht als ID verwendet werden

# TODO 308: make a better error message
compiler.err.this.as.identifier=Ab Release 8 ist "this" nur als Parametername f\u00FCr den Empf\u00E4ngertyp zul\u00E4ssig.\nDas muss der erste Parameter sein und darf kein Lambda-Parameter sein

compiler.err.receiver.parameter.not.applicable.constructor.toplevel.class=receiver-Parameter nicht f\u00FCr Konstruktor der obersten Klasse anwendbar

# TODO 308: make a better error message
# 0: annotation
compiler.err.cant.type.annotate.scoping.1=Scoping-Konstrukt kann nicht mit type-use-Annotation versehen werden: {0}

# TODO 308: make a better error message
# 0: list of annotation
compiler.err.cant.type.annotate.scoping=Scoping-Konstrukt kann nicht mit type-use-Annotationen versehen werden: {0}

# 0: type, 1: type
compiler.err.incorrect.receiver.name=Der Empf\u00E4ngername stimmt nicht mit dem einschlie\u00DFenden Klassentyp \u00FCberein\nErforderlich: {0}\nErmittelt:    {1}

# 0: type, 1: type
compiler.err.incorrect.receiver.type=Der Empf\u00E4ngertyp stimmt nicht mit dem einschlie\u00DFenden Klassentyp \u00FCberein\nErforderlich: {0}\nErmittelt:    {1}

# 0: type, 1: type
compiler.err.incorrect.constructor.receiver.type=Der Empf\u00E4ngertyp stimmt nicht mit dem einschlie\u00DFenden \u00E4u\u00DFeren Klassentyp \u00FCberein\nErforderlich: {0}\nErmittelt:    {1}

# 0: type, 1: type
compiler.err.incorrect.constructor.receiver.name=Der Empf\u00E4ngername stimmt nicht mit dem einschlie\u00DFenden \u00E4u\u00DFeren Klassentyp \u00FCberein\nErforderlich: {0}\nErmittelt:    {1}

compiler.err.no.annotations.on.dot.class=Keine Annotationen im Typ eines Klassenliterals zul\u00E4ssig

########################################
# Diagnostics for verbose resolution
# used by Resolve (debug only)
########################################

# 0: number, 1: symbol, 2: unused
compiler.misc.applicable.method.found=#{0} anwendbare Methode gefunden: {1}

# 0: number, 1: symbol, 2: message segment
compiler.misc.applicable.method.found.1=#{0} anwendbare Methode gefunden: {1}\n({2})

# 0: number, 1: symbol, 2: message segment
compiler.misc.not.applicable.method.found=#{0} nicht anwendbare Methode gefunden: {1}\n({2})

# 0: type
compiler.misc.partial.inst.sig=Teilweise instanziiert in: {0}

# 0: name, 1: symbol, 2: number, 3: string (method resolution phase), 4: list of type or message segment, 5: list of type or message segment
compiler.note.verbose.resolve.multi=Methode {0} wird in Typ {1} als Kandidat {2} aufgel\u00F6st\nPhase: {3}\nMit Istwerten: {4}\nMit type-args: {5}\nKandidaten:

# 0: name, 1: symbol, 2: unused, 3: string (method resolution phase), 4: list of type or message segment, 5: list of type or message segment
compiler.note.verbose.resolve.multi.1=Fehlerhafte Aufl\u00F6sung f\u00FCr Methode {0} in Typ {1}\nPhase: {3}\nMit Istwerten: {4}\nMit type-args: {5}\nKandidaten:

# 0: symbol, 1: type, 2: type
compiler.note.deferred.method.inst=Instanziierung von Methode {0} verz\u00F6gert\nInstanziierte Signatur: {1}\ntarget-type: {2}

########################################
# Diagnostics for lambda deduplication
# used by LambdaToMethod (debug only)
########################################

# 0: symbol
compiler.note.verbose.l2m.deduplicate=Lambda-Implementierungsmethode {0} wird dedupliziert

########################################
# Diagnostics for method reference search
# results used by Resolve (debug only)
########################################

# 0: fragment, 1: string, 2: number
compiler.note.method.ref.search.results.multi={0} Suchergebnisse f\u00FCr {1}, mit spezifischsten {2}\nAnwendbare Kandidaten:

# 0: number, 1: fragment, 2: symbol
compiler.misc.applicable.method.found.2=#{0} anwendbare Methode gefunden: {1} {2}

# 0: number, 1: fragment, 2: symbol, 3: message segment
compiler.misc.applicable.method.found.3=#{0} anwendbare Methode gefunden: {1} {2}\n({3})

compiler.misc.static=statisch

compiler.misc.non.static=nicht statisch

compiler.misc.bound=gebunden

compiler.misc.unbound=ungebunden

########################################
# Diagnostics for where clause implementation
# used by the RichDiagnosticFormatter.
########################################

compiler.misc.type.null=<Null>

# X#n (where n is an int id) is disambiguated tvar name
# 0: name, 1: number
compiler.misc.type.var={0}#{1}

# CAP#n (where n is an int id) is an abbreviation for 'captured type'
# 0: number
compiler.misc.captured.type=CAP#{0}

# <INT#n> (where n is an int id) is an abbreviation for 'intersection type'
# 0: number
compiler.misc.intersection.type=INT#{0}

# where clause for captured type: contains upper ('extends {1}') and lower
# ('super {2}') bound along with the wildcard that generated this captured type ({3})
# 0: type, 1: type, 2: type, 3: type
compiler.misc.where.captured={0} erweitert {1} Super: {2} aus Erfassung von {3}

# compact where clause for captured type: contains upper ('extends {1}') along
# with the wildcard that generated this captured type ({3})
# 0: type, 1: type, 2: unused, 3: type
compiler.misc.where.captured.1={0} erweitert {1} aus Erfassung von {3}

# where clause for type variable: contains upper bound(s) ('extends {1}') along with
# the kindname ({2}) and location ({3}) in which the typevar has been declared
# 0: type, 1: list of type, 2: symbol kind, 3: symbol
compiler.misc.where.typevar={0} erweitert {1}, deklariert in {2} {3}

# compact where clause for type variable: contains the kindname ({2}) and location ({3})
# in which the typevar has been declared
# 0: type, 1: list of type, 2: symbol kind, 3: symbol
compiler.misc.where.typevar.1={0} deklariert in {2} {3}

# where clause for fresh type variable: contains upper bound(s) ('extends {1}').
# Since a fresh type-variable is synthetic - there's no location/kindname here.
# 0: type, 1: list of type
compiler.misc.where.fresh.typevar={0} erweitert {1}

# where clause for type variable: contains all the upper bound(s) ('extends {1}')
# of this intersection type
# 0: type, 1: list of type
compiler.misc.where.intersection={0} erweitert {1}

### Where clause headers ###
compiler.misc.where.description.captured=Dabei ist {0} eine neue Typvariable:

# 0: set of type
compiler.misc.where.description.typevar=Dabei ist {0} eine Typvariable:

# 0: set of type
compiler.misc.where.description.intersection=Dabei ist {0} ein Schnittmengentyp:

# 0: set of type
compiler.misc.where.description.captured.1=Dabei sind {0} neue Typvariablen:

# 0: set of type
compiler.misc.where.description.typevar.1=Dabei sind {0} Typvariablen:

# 0: set of type
compiler.misc.where.description.intersection.1=Dabei sind {0} Schnittmengentypen:

###
# errors related to doc comments

compiler.err.dc.bad.entity=Ung\u00FCltige HTML-Entity

compiler.err.dc.bad.inline.tag=Falsche Verwendung von Inlinetag

compiler.err.dc.identifier.expected=ID erwartet

compiler.err.dc.malformed.html=Nicht wohlgeformte HTML

compiler.err.dc.missing.semicolon=Semikolon fehlt

compiler.err.dc.no.content=kein Inhalt

compiler.err.dc.no.tag.name=Kein Tagname nach "@"

compiler.err.dc.gt.expected=">" erwartet

compiler.err.dc.ref.bad.parens=Unerwarteter Text nach Klammer

compiler.err.dc.ref.syntax.error=Syntaxfehler in Referenz

compiler.err.dc.ref.unexpected.input=Unerwarteter Text

compiler.err.dc.unexpected.content=Unerwarteter Inhalt

compiler.err.dc.unterminated.inline.tag=Nicht abgeschlossenes Inlinetag

compiler.err.dc.unterminated.signature=Nicht abgeschlossene Signatur

compiler.err.dc.unterminated.string=Nicht abgeschlossene Zeichenfolge

compiler.err.dc.ref.annotations.not.allowed=Annotationen nicht zul\u00E4ssig

###
# errors related to modules

compiler.err.expected.module="module" erwartet

# 0: symbol
compiler.err.module.not.found=Modul nicht gefunden: {0}

# 0: symbol
compiler.warn.module.not.found=Modul nicht gefunden: {0}

compiler.err.too.many.modules=Zu viele Moduldeklarationen gefunden

compiler.err.module.not.found.on.module.source.path=Modul nicht in Modulquellpfad gefunden

compiler.err.not.in.module.on.module.source.path=Nicht in einem Modul im Modulquellpfad

# 0: symbol
compiler.err.duplicate.module=Doppeltes Modul: {0}

# 0: symbol
compiler.err.duplicate.requires=Doppelte "requires": {0}

# 0: symbol
compiler.err.conflicting.exports=Doppelte oder unvereinbare Exporte: {0}

# 0: symbol
compiler.err.conflicting.opens=Doppelte oder unvereinbare "opens": {0}

# 0: symbol
compiler.err.conflicting.exports.to.module=Doppelte oder unvereinbare Exporte in Modul: {0}

# 0: symbol
compiler.err.conflicting.opens.to.module=Doppelte oder unvereinbare "opens" in Modul: {0}

compiler.err.no.opens.unless.strong="opens" nur in starken Modulen zul\u00E4ssig

# 0: symbol
compiler.err.repeated.provides.for.service=Mehrere "provides" f\u00FCr Service {0}

# 0: symbol, 1: symbol
compiler.err.duplicate.provides=Doppelte "provides": Service {0}, Implementierung {1}

# 0: symbol
compiler.err.duplicate.uses=Doppelte Verwendungen: {0}

# 0: symbol
compiler.err.service.implementation.is.abstract=Die Serviceimplementierung ist eine abstrakte Klasse: {0}

compiler.err.service.implementation.must.be.subtype.of.service.interface=Der Serviceimplementierungstyp muss ein Subtyp des Serviceschnittstellentyps sein oder eine \u00F6ffentliche statische no-args-Methode namens "provider" aufweisen, die die Serviceimplementierung zur\u00FCckgibt

compiler.err.service.implementation.provider.return.must.be.subtype.of.service.interface=Der R\u00FCckgabetyp der "provider"-Methode muss ein Subtyp des Serviceschnittstellentyps sein

# 0: symbol
compiler.err.service.implementation.is.inner=Die Serviceimplementierung ist eine innere Klasse: {0}

# 0: symbol
compiler.err.service.definition.is.enum=Die Servicedefinition ist eine Enumeration: {0}

# 0: symbol
compiler.err.service.implementation.doesnt.have.a.no.args.constructor=Die Serviceimplementierung hat keinen Standardkonstruktor: {0}

# 0: symbol
compiler.err.service.implementation.no.args.constructor.not.public=Der "no arguments"-Konstruktor der Serviceimplementierung ist nicht \u00F6ffentlich: {0}

# 0: symbol
compiler.err.package.empty.or.not.found=Package ist leer oder nicht vorhanden: {0}

# 0: symbol
compiler.warn.package.empty.or.not.found=Package ist leer oder nicht vorhanden: {0}

compiler.err.no.output.dir=Kein Klassenausgabeverzeichnis angegeben

compiler.err.unnamed.pkg.not.allowed.named.modules=Unbenanntes Package ist in benannten Modulen nicht zul\u00E4ssig

# 0: name, 1: name
compiler.err.module.name.mismatch=Modulname {0} stimmt nicht mit dem erwarteten Namen {1} \u00FCberein

# 0: name, 1: name
compiler.misc.module.name.mismatch=Modulname {0} stimmt nicht mit dem erwarteten Namen {1} \u00FCberein

# 0: name
compiler.err.module.non.zero.opens=Bei ge\u00F6ffnetem Modul {0} ist opens_count ungleich Null

# 0: name
compiler.misc.module.non.zero.opens=Bei ge\u00F6ffnetem Modul {0} ist opens_count ungleich Null

compiler.err.module.decl.sb.in.module-info.java=Moduldeklarationen m\u00FCssen in einer Datei namens module-info.java vorhanden sein

# 0: set of string
compiler.err.too.many.patched.modules=Zu viele gepatchte Module ({0}). Verwenden Sie --module-source-path

# 0: name, 1: name
compiler.err.file.patched.and.msp=Datei sowohl von --patch-module als auch von --module-source-path zug\u00E4nglich, geh\u00F6rt aber in jedem Pfad zu einem anderen Modul: {0}, {1}

compiler.err.processorpath.no.processormodulepath=Unzul\u00E4ssige Kombination aus -processorpath und --processor-module-path

# 0: symbol
compiler.err.package.in.other.module=Package ist in einem anderen Modul vorhanden: {0}

# 0: symbol, 1: name, 2: symbol, 3: symbol
compiler.err.package.clash.from.requires=Modul {0} liest Package {1} sowohl aus {2} als auch aus {3}

# 0: name, 1: symbol, 2: symbol
compiler.err.package.clash.from.requires.in.unnamed=Das unbenannte Modul liest Package {0} sowohl aus {1} als auch aus {2}

# 0: string
compiler.err.module.not.found.in.module.source.path=Modul {0} nicht in Modulquellpfad gefunden

compiler.err.output.dir.must.be.specified.with.dash.m.option=Klassenausgabeverzeichnis muss angegeben werden, wenn die Option -m verwendet wird

compiler.err.modulesourcepath.must.be.specified.with.dash.m.option=Modulquellpfad muss angegeben werden, wenn die Option -m verwendet wird

# 0: symbol
compiler.err.service.implementation.not.in.right.module=Serviceimplementierung muss in demselben Modul wie die provides-Direktive definiert werden

# 0: symbol
compiler.err.cyclic.requires=Zyklische Abh\u00E4ngigkeit mit {0}

# 0: fragment, 1: name
compiler.err.duplicate.module.on.path=Doppeltes Modul in {0}\nModul in {1}

# 0: option name, 1: string
compiler.warn.bad.name.for.option=Ung\u00FCltiger Name im Wert f\u00FCr {0}-Option: "{1}"

# 0: option name, 1: string
compiler.err.bad.name.for.option=Ung\u00FCltiger Name im Wert f\u00FCr {0}-Option: "{1}"

# 0: option name, 1: symbol
compiler.warn.module.for.option.not.found=Modulname in {0}-Option nicht gefunden: {1}

compiler.err.addmods.all.module.path.invalid=--add-modules ALL-MODULE-PATH kann nur beim Kompilieren des unbenannten Moduls oder beim Kompilieren im Kontext eines automatischen Moduls verwendet werden

# 0: symbol
compiler.err.add.exports.with.release=Export eines Packages aus Systemmodul {0} ist mit --release nicht zul\u00E4ssig

# 0: symbol
compiler.err.add.reads.with.release=Hinzuf\u00FCgen von Lese-Edges f\u00FCr Systemmodul {0} ist mit --release nicht zul\u00E4ssig

compiler.warn.addopens.ignored=--add-opens hat zur Kompilierungszeit keine Auswirkungen

compiler.misc.locn.module_source_path=Modulquellpfad

compiler.misc.locn.upgrade_module_path=Upgrademodulpfad

compiler.misc.locn.system_modules=Systemmodule

compiler.misc.locn.module_path=Anwendungsmodulpfad

compiler.misc.cant.resolve.modules=Module k\u00F6nnen nicht aufgel\u00F6st werden

compiler.misc.bad.requires.flag=Ung\u00FCltiges requires-Kennzeichen: {0}

# 0: string
compiler.err.invalid.module.specifier=Modulbezeichner nicht zul\u00E4ssig: {0}

# 0: symbol
compiler.warn.service.provided.but.not.exported.or.used=Serviceschnittstelle angegeben, aber nicht exportiert oder verwendet

# 0: kind name, 1: symbol, 2: symbol
compiler.warn.leaks.not.accessible={0} {1} in Modul {2} ist nicht zug\u00E4nglich f\u00FCr Clients, die dieses Modul ben\u00F6tigen
# 0: kind name, 1: symbol, 2: symbol
compiler.warn.leaks.not.accessible.unexported={0} {1} in Modul {2} wird nicht exportiert
# 0: kind name, 1: symbol, 2: symbol
compiler.warn.leaks.not.accessible.not.required.transitive={0} {1} in Modul {2} wird nicht indirekt mit "requires transitive" exportiert
# 0: kind name, 1: symbol, 2: symbol
compiler.warn.leaks.not.accessible.unexported.qualified={0} {1} in Modul {2} ist m\u00F6glichweise nicht f\u00FCr alle Clients, die dieses Modul ben\u00F6tigen, sichtbar

###
# errors related to options

# 0: string, 1: string
compiler.err.illegal.argument.for.option=Unzul\u00E4ssiges Argument f\u00FCr {0}: {1}

compiler.err.match.binding.exists=Unzul\u00E4ssiger Versuch, ein vorhandenes \u00DCbereinstimmungs-Binding neu zu definieren

compiler.err.switch.case.unexpected.statement=Unerwartete Anweisung in Case. Ausdruck, Block oder throw-Anweisung erwartet

compiler.err.switch.mixing.case.types=Unterschiedliche Case-Typen im Switch verwendet

###
# errors related to sealed classes

# permits clause
# 0: fragment
compiler.err.invalid.permits.clause=Ung\u00FCltige PERMITS-Klausel\n({0})

# 0: string
compiler.misc.class.is.not.sealed={0} muss verschl\u00FCsselt sein

# 0: type
compiler.misc.is.a.type.variable=Darf keine Typvariablen enthalten: {0}

# 0: type
compiler.misc.is.duplicated=Darf keine Duplikate enthalten: {0}

# 0: type
compiler.misc.doesnt.extend.sealed=Unterklasse {0} muss verschl\u00FCsselte Klasse erweitern

compiler.misc.must.not.be.same.class=Unzul\u00E4ssige Selbstreferenz in PERMITS-Klausel

# 0: type
compiler.misc.must.not.be.supertype=Unzul\u00E4ssige Referenz zu Supertyp {0}

# other sealed types related errors

compiler.err.sealed.class.must.have.subclasses=Verschl\u00FCsselte Klasse muss Unterklassen aufweisen

# errors in subclasses of sealed classes
# 0: symbol
compiler.err.cant.inherit.from.sealed=Klasse darf nicht verschl\u00FCsselte Klasse erweitern: {0} (da diese nicht in der "permits"-Klausel enthalten ist)

# 0: symbol
compiler.err.class.in.unnamed.module.cant.extend.sealed.in.diff.package=Klasse {0} in unbenanntem Modul darf keine verschl\u00FCsselte Klasse in einem anderen Package erweitern

# 0: symbol, 1: symbol
compiler.err.class.in.module.cant.extend.sealed.in.diff.module=Klasse {0} in Modul {1} darf keine verschl\u00FCsselte Klasse in einem anderen Modul erweitern

# 0: symbol
compiler.err.non.sealed.with.no.sealed.supertype=Modifikator "non-sealed" ist hier nicht zul\u00E4ssig\n(Klasse {0} hat keine verschl\u00FCsselten Supertypen)

compiler.err.non.sealed.sealed.or.final.expected=Modifikator "sealed", "non-sealed" oder "final" erwartet

compiler.err.non.sealed.or.sealed.expected=Modifikator "sealed" oder "non-sealed" erwartet

compiler.err.sealed.or.non.sealed.local.classes.not.allowed=Lokale Klassen mit "sealed" oder "non-sealed" nicht zul\u00E4ssig

# 0: fragment
compiler.err.local.classes.cant.extend.sealed=Klassen vom Typ "{0}" d\u00FCrfen keine verschl\u00FCsselten Klassen erweitern
compiler.misc.anonymous=Anonym

compiler.misc.local=Lokal

###
# errors related to records

# record components
compiler.err.record.cant.declare.field.modifiers=Datensatzkomponenten k\u00F6nnen keine Modifikatoren aufweisen

# 0: symbol
compiler.err.illegal.record.component.name=Unzul\u00E4ssiger Datensatzkomponentenname {0}

compiler.err.record.component.and.old.array.syntax=Legacy-Arraynotation f\u00FCr Datensatzkomponenten nicht zul\u00E4ssig

# accessor methods
# 0: symbol, 1: fragment
compiler.err.invalid.accessor.method.in.record=Ung\u00FCltige Accessor-Methode in Datensatz {0}\n({1})

compiler.misc.method.must.be.public=Accessor-Methode muss \u00F6ffentlich sein

# 0: symbol, 1: symbol
compiler.misc.accessor.return.type.doesnt.match=R\u00FCckgabetyp von Accessor-Methode {0} muss mit dem Typ der Datensatzkomponente {1} \u00FCbereinstimmen

compiler.misc.accessor.method.cant.throw.exception=Throws-Klausel f\u00FCr Accessor-Methode nicht zul\u00E4ssig

compiler.misc.accessor.method.must.not.be.generic=Accessor-Methode darf nicht generisch sein

compiler.misc.accessor.method.must.not.be.static=Accessor-Methode darf nicht statisch sein

# canonical constructors
# 0: fragment, 1: name, 2: fragment
compiler.err.invalid.canonical.constructor.in.record=Ung\u00FCltiger Konstruktor vom Typ {0} in Datensatz {1}\n({2})

compiler.misc.canonical=Kanonisch

compiler.misc.compact=Kompakt

# 0: fragment
compiler.misc.throws.clause.not.allowed.for.canonical.constructor=Throws-Klausel f\u00FCr Konstruktor des Typs {0} nicht zul\u00E4ssig

compiler.misc.canonical.with.name.mismatch=Ung\u00FCltige Parameternamen in kanonischem Konstruktor

compiler.misc.canonical.cant.have.return.statement=Kompakter Konstruktor darf keine return-Anweisungen verwenden

compiler.misc.canonical.must.not.declare.type.variables=Kanonischer Konstruktor darf keine Typvariablen deklarieren

compiler.misc.type.must.be.identical.to.corresponding.record.component.type=Typ und Argumentanzahl m\u00FCssen mit den Werten der entsprechenden Datensatzkomponente \u00FCbereinstimmen
compiler.misc.canonical.must.not.contain.explicit.constructor.invocation=Kanonischer Konstruktor darf keinen expliziten Konstruktoraufruf enthalten

# 0: set of flag or string
compiler.misc.canonical.must.not.have.stronger.access=Versuch, h\u00F6here Zugriffsberechtigungen zuzuweisen. War {0}

# other
compiler.err.record.cannot.declare.instance.fields=Felddeklaration muss statisch sein\n(ersetzen Sie unter Umst\u00E4nden das Feld durch eine Datensatzkomponente)

# 0: symbol
compiler.err.invalid.supertype.record=Klassen k\u00F6nnen {0} nicht direkt erweitern

# 0: symbol
compiler.err.first.statement.must.be.call.to.another.constructor=Konstruktor ist nicht kanonisch. Daher muss die erste Anweisung einen anderen Konstruktor der Klasse {0} aufrufen

compiler.err.instance.initializer.not.allowed.in.records=Instanz-Initializer in Datens\u00E4tzen nicht zul\u00E4ssig

compiler.err.static.declaration.not.allowed.in.inner.classes=Statische Deklarationen in inneren Klassen nicht zul\u00E4ssig

compiler.err.record.header.expected=Datensatzheader erwartet

############################################
# messages previously at javac.properties

compiler.err.empty.A.argument=-A erfordert ein Argument. Verwenden Sie "-Akey" oder "-Akey=value"

# 0: string
compiler.err.invalid.A.key=Schl\u00FCssel in Annotationsprozessoroption "{0}" ist keine durch Punkt getrennte ID-Sequenz

# 0: string
compiler.err.invalid.flag=Ung\u00FCltiges Kennzeichen: {0}

compiler.err.profile.bootclasspath.conflict=Optionen "profile" und "bootclasspath" k\u00F6nnen nicht zusammen verwendet werden

# 0: string
compiler.err.invalid.profile=Ung\u00FCltiges Profil: {0}

# 0: string
compiler.err.invalid.target=Ung\u00FCltiges Zielrelease: {0}

# 0: option name, 1: target
compiler.err.option.not.allowed.with.target=Option {0} mit Ziel {1} nicht zul\u00E4ssig

# 0: string
compiler.err.option.too.many=Option {0} kann nur einmal angegeben werden

compiler.err.no.source.files=Keine Quelldateien

compiler.err.no.source.files.classes=Keine Quelldateien oder Klassennamen

# 0: string
compiler.err.req.arg={0} erfordert ein Argument

# 0: string
compiler.err.invalid.source=Ung\u00FCltiges Quellrelease: {0}

# 0: string, 1: string
compiler.err.error.writing.file=Fehler beim Schreiben von {0}. {1}

compiler.err.sourcepath.modulesourcepath.conflict=--source-path und --module-source-path k\u00F6nnen nicht beide angegeben werden

# 0: string, 1: target
compiler.warn.source.target.conflict=Quellrelease {0} erfordert Zielrelease {1}

# 0: string, 1: target
compiler.warn.target.default.source.conflict=Zielrelease {0} steht mit Standardquellrelease {1} in Konflikt

# 0: profile, 1: target
compiler.warn.profile.target.conflict=Profil {0} ist f\u00FCr Zielrelease {1} nicht g\u00FCltig

# 0: string
compiler.err.file.not.directory=Kein Verzeichnis: {0}

# 0: object
compiler.err.file.not.file=Keine Datei: {0}

compiler.err.two.class.loaders.1=javac ist auf mehrere Class Loader aufgeteilt: Pr\u00FCfen Sie die Konfiguration

# 0: url, 1: url
compiler.err.two.class.loaders.2=javac ist auf mehrere Class Loader aufgeteilt:\nEine Klasse stammt aus Datei {0},\nw\u00E4hrend javac aus {1} stammt

# 0: string, 1: string
compiler.err.bad.value.for.option=Ung\u00FCltiger Wert f\u00FCr {0}-Option: "{1}"

# 0: string
compiler.err.no.value.for.option=Kein Wert f\u00FCr {0}-Option

# 0: string
compiler.err.repeated.value.for.patch.module=--patch-module mehrmals f\u00FCr Modul {0} angegeben

# 0: string
compiler.err.repeated.value.for.module.source.path=--module-source-path mehrmals f\u00FCr Modul {0} angegeben

compiler.err.multiple.values.for.module.source.path=--module-source-path mehrmals mit Musterargument angegeben

# 0: string
compiler.err.unmatched.quote=Alleinstehendes Anf\u00FChrungszeichen in Umgebungsvariable {0}

# 0: option name
compiler.err.release.bootclasspath.conflict=Option {0} kann nicht zusammen mit --release verwendet werden

# 0: string
compiler.err.unsupported.release.version=Releaseversion {0} nicht unterst\u00FCtzt

# 0: string
compiler.err.file.not.found=Datei nicht gefunden: {0}

# 0: string, 1: source
compiler.err.preview.not.latest=Ung\u00FCltiges Quellrelease {0} mit --enable-preview\n(Vorschausprachfeatures werden nur f\u00FCr Release {1} unterst\u00FCtzt)

compiler.err.preview.without.source.or.release=--enable-preview muss mit -source oder --release verwendet werden

# 0: kind name, 1: symbol
compiler.warn.declared.using.preview={0} {1} ist mit einem Vorschaufeature deklariert, das in einem zuk\u00FCnftigen Release entfernt werden kann.

compiler.warn.attempt.to.synchronize.on.instance.of.value.based.class=Versuch der Synchronisierung f\u00FCr eine Instanz einer wertbasierten Klasse
